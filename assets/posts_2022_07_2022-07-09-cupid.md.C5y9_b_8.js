import{_ as a,a as i,af as r,o as t}from"./chunks/framework.C87LdZyP.js";const k=JSON.parse('{"title":"CUPID 原则","description":"","frontmatter":{"title":"CUPID 原则","date":"2022-07-09T00:00:00.000Z","tags":["架构"],"category":["架构"]},"headers":[],"relativePath":"posts/2022/07/2022-07-09-cupid.md","filePath":"posts/2022/07/2022-07-09-cupid.md","lastUpdated":1718173059000}'),s={name:"posts/2022/07/2022-07-09-cupid.md"};function n(l,e,o,p,h,d){return t(),i("div",null,e[0]||(e[0]=[r(`<p>五个 CUPID 属性：</p><ul><li><strong>Composable / 可组合</strong></li><li><strong>Unix philosophy</strong> 做好一件事</li><li><strong>Predictable / 可预测</strong></li><li><strong>Idiomatic / 惯用语</strong></li><li><strong>Domain-based / 基于领域</strong></li></ul><h2 id="快乐软件-joyful-software" tabindex="-1">快乐软件 Joyful software <a class="header-anchor" href="#快乐软件-joyful-software" aria-label="Permalink to &quot;快乐软件 Joyful software&quot;">​</a></h2><p>让人愉快工作的代码：</p><ul><li>你知道如何找到你需要做的事情。</li><li>你知道如何做出你需要的改变。</li><li>该代码易于浏览，易于理解，易于推理。</li><li>您确信您的更改将产生您想要的效果， 而不会产生任何过度的副作用。</li><li>代码 <em>引导你</em> ，邀请你浏览。</li><li>比你先来的程序员在乎以后来的人，也许是因为他们意识到后来来的程序员可能就是他们！</li></ul><p>Martin Fowler 在他的开创性著作《重构》中说：</p><blockquote><p>『任何傻瓜都可以编写计算机可以理解的代码。优秀的程序员编写人类可以理解的代码。』</p><p>—<em><a href="https://martinfowler.com/books/refactoring.html" title="重构：改进现有代码的设计" target="_blank" rel="noreferrer">重构</a>，Martin Fowler 和 Kent Beck，1996</em></p></blockquote><p>我在 2000 年代初读到了这篇文章，他的话让我的编程世界彻底颠覆了。 如果好的编程是<em>为了让其他人</em>可以理解代码呢？ 如果其中一个人类是未来的我怎么办？ 这听起来像是一件令人向往的事情。</p><p>但是，虽然『可以理解』可能是一个崇高的愿望，但它并不是那么高的标准！ 大约在 Martin 撰写有关重构的文章的同时，计算先驱<a href="https://www.dreamsongs.com" title="梦歌" target="_blank" rel="noreferrer">Richard P. Gabriel</a>描述了代码*宜居住（habitable）*的想法：</p><blockquote><p>『宜居性是源代码的特性，它使 [人们] 能够理解其构造和意图，并舒适而自信地对其进行更改。』</p><p>『宜居性使一个地方像家一样宜居。』</p><p><em>-- 可居住性和零碎增长 <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>(<a href="https://dannorth.net/2022/02/10/cupid-for-joyful-coding/#fn:1" target="_blank" rel="noreferrer">https://dannorth.net/2022/02/10/cupid-for-joyful-coding/#fn:1</a>)^ ，<a href="https://www.dreamsongs.com/Files/PatternsOfSoftware.pdf" title="软件模式：来自软件社区的故事" target="_blank" rel="noreferrer">软件模式</a>第 7-16 页，Richard P. Gabriel</em></p></blockquote><p>这感觉更像是要争取的东西。改变其他人的代码时感到<em>自在</em>和<em>自信</em>会有多好？如果我们可以让代码变得宜居，那么<em>快乐</em>呢？代码库有可能让你充满喜悦吗？</p><p>如果您将工作日花在编程上，那么导航和操作代码库将定义您的用户体验。你可以体验到惊喜、沮丧、恐惧、期待、无助、希望、喜悦， 这一切都是因为早期程序员在代码库中做出的选择。</p><p>如果我们假设代码库可能是快乐的，那么每个代码库是否都有自己特殊的雪花，它对你的心灵的影响是独一无二的？ 或者我们能否阐明是什么让它变得快乐，并提供一条途径来增加我们接触的代码的快乐？</p><h2 id="属性高于原则" tabindex="-1">属性高于原则 <a class="header-anchor" href="#属性高于原则" aria-label="Permalink to &quot;属性高于原则&quot;">​</a></h2><p>当我开始对 SOLID 的五项原则做出回应时，我设想用我认为更有用或更相关的东西来替换每一项。 我很快意识到原则的想法本身是有问题的。原则就像规则：你要么顺从，要么不顺从。 这产生了规则追随者和规则执行者的“有界集合”，而不是具有共同价值观的人的“中心集合”。</p><p>相反，我开始考虑 <em>属性</em> ：代码的品质或特征，而不是要遵循的规则。 属性定义要移动的目标或中心。您的代码只是离中心更近或更远，并且始终有明确的行进方向。 您可以使用属性作为透镜或过滤器来评估您的代码，并且您可以决定接下来要解决哪些问题。 由于 CUPID 属性都是相互关联的，因此您为改进一个属性所做的任何更改都可能对其他一些属性产生积极影响。</p><h2 id="属性的属性" tabindex="-1">属性的属性 <a class="header-anchor" href="#属性的属性" aria-label="Permalink to &quot;属性的属性&quot;">​</a></h2><p>那么我们如何选择属性呢？是什么让属性或多或少有用？我决定了三个我希望 CUPID 属性具有的“属性的属性”。它们应该是<em>实用</em>的、 <em>人性化</em>的 、有<em>层次</em>的。</p><p>为了 <strong>实用</strong> ，属性需要：</p><ul><li>易于 <strong>表达</strong> ：因此您可以用几句话描述它们中的每一个，并提供具体的例子和反例。</li><li>易于 <strong>评估</strong> ：因此您可以将它们用作审查和讨论代码的透镜，并且您可以轻松确定代码展示了每个属性的程度。</li><li>易于 <strong>采用</strong> ：因此您可以从小规模开始并沿着任何 CUPID 维度逐步发展代码。没有“全押”，也没有“失败”，就像从来没有“完成”一样。代码总是可以改进的。</li></ul><p>作为 <strong>人</strong> ，属性需要从<em>人</em>的角度来阅读，而不是代码。 CUPID 是关于使用代码的感觉，而不是对代码本身的抽象描述。 例如，虽然“做好一件事”的 Unix 哲学听起来像是单一职责原则， 但前者是关于你如何使用代码，而后者是关于代码本身的内部结构。</p><p>要 <strong>分层</strong> ，属性应该为初学者提供 <em>指导</em>（这是易于表达的结果）， 并为那些发现自己想要更深入地探索软件本质的更有经验的人提供 <em>细微差别</em>。 每个 CUPID 属性都是“显而易见的”，只是名称和简要描述，但每个属性都包含许多层、维度和方法。 我们也许可以描述每个属性的“中心”，但是有很多路径可以到达那里！</p><hr><h2 id="可组合" tabindex="-1">可组合 <a class="header-anchor" href="#可组合" aria-label="Permalink to &quot;可组合&quot;">​</a></h2><p>易于使用的软件会被使用、使用并再次使用。 有一些特征使代码或多或少可组合，但这些对于做出任何保证既不是必要的也不是充分的。 在每种情况下，我们都可以找到双方的反例，因此您应该将这些视为有用的启发式方法。 更多不一定更好；这都是取舍。</p><h3 id="小面积" tabindex="-1">小面积 <a class="header-anchor" href="#小面积" aria-label="Permalink to &quot;小面积&quot;">​</a></h3><p>具有狭窄、固执己见的 API 的代码让您学习的东西更少，出错的可能性也更少，与您正在使用的其他代码发生冲突或不一致的可能性也更小。 这有一个递减的回报；如果您的 API 太窄，您会发现自己将它们组合在一起使用，并且了解常见用例的“正确组合”会成为可能成为进入障碍的隐性知识。 获得正确的 API 粒度比看起来更难。碎片化和臃肿之间有一个“恰到好处”的凝聚力。</p><h3 id="展示意图" tabindex="-1">展示意图 <a class="header-anchor" href="#展示意图" aria-label="Permalink to &quot;展示意图&quot;">​</a></h3><p>展示意图代码很容易发现和评估。 我可以很容易地找到您的组件，并尽快确定它是否是我需要的东西。 我喜欢的一个模型（来自像古老的<a href="https://x-stream.github.io/tutorial.html" target="_blank" rel="noreferrer">XStream</a>）。 这样的开源项目——有一个 2 分钟的教程、一个 10 分钟的教程和一个深入研究。 这让我可以增量投资，并在我发现这不适合我时立即退出。</p><p>我不止一次开始编写一个类，给它一个展示意图的名称，只是为了让 IDE 弹出一个具有相同名称的建议导入。 通常结果是其他人也有同样的想法，我偶然发现了他们的代码，因为我们选择了相似的名字。 这不仅仅是巧合；我们精通同一个领域，这使得我们更有可能选择相似的名字。当您拥有<strong>基于域</strong>的代码时，这种情况更有可能发生。</p><h3 id="最小依赖" tabindex="-1">最小依赖 <a class="header-anchor" href="#最小依赖" aria-label="Permalink to &quot;最小依赖&quot;">​</a></h3><p>具有最小依赖性的代码让您不必担心，并降低版本或库不兼容的可能性。 我用 Java 编写了我的第一个开源项目<a href="https://github.com/codehaus/xjb" target="_blank" rel="noreferrer">XJB</a>，并使用了几乎无处不在的<code>log4j</code>日志框架。 一位同事指出，这创建了一个依赖关系，不仅<code>log4j</code>作为库，而且在特定版本上。我什至没有想到。 为什么有人要担心像日志库这样无害的东西？因此，我们<a href="https://github.com/codehaus/xjb/commit/ed711436dcdb88b129a15f779a72f4247680ef0e" target="_blank" rel="noreferrer">删除了依赖项</a>， 甚至提取了一个<a href="https://github.com/proxytoys" target="_blank" rel="noreferrer">完整的其他项目</a>，该项目使用 Java 动态代理做有趣的事情，它本身具有最小的依赖项。</p><hr><h2 id="unix-哲学" tabindex="-1">Unix 哲学 <a class="header-anchor" href="#unix-哲学" aria-label="Permalink to &quot;Unix 哲学&quot;">​</a></h2><p>Unix和我差不多大；我们都始于 1969 年，而 Unix 已成为地球上最流行的操作系统。 在 1990 年代，每个严肃的计算机硬件制造商都有自己的 Unix，直到关键的开源变体 Linux 和 FreeBSD 变得无处不在。 如今，它以 Linux 的形式运行几乎所有的业务服务器，包括云服务器和本地服务器； 它在嵌入式系统和网络设备中运行；它支持 macOS 和 Android 操作系统；它甚至作为 Microsoft Windows 的可选子系统提供！</p><h3 id="一个简单、一致的模型" tabindex="-1">一个简单、一致的模型 <a class="header-anchor" href="#一个简单、一致的模型" aria-label="Permalink to &quot;一个简单、一致的模型&quot;">​</a></h3><p>那么，一个从电信研究实验室开始的小众操作系统是如何被一个大学生作为爱好项目复制的，最终成为世界上最大的操作系统呢？ 毫无疑问，在一个操作系统供应商以相互诉讼而闻名的时代，它的成功有商业和法律原因， 但其经久不衰的技术吸引力在于其简单而一致的<a href="https://en.wikipedia.org/wiki/Unix_philosophy" target="_blank" rel="noreferrer">设计理念</a>。</p><p>Unix 哲学说要编写能够很好地协同工作的 [组件]，在上面的可组合性属性中进行了描述，并且 <em>做一件事并且做得好</em> 。 例如，该<code>ls</code>命令列出了有关文件和目录的详细信息，但它对文件或目录 <em>一无所知</em> ！有一个<code>stat</code>提供信息的系统命令；<code>ls</code>只是一种将信息呈现为文本的工具。</p><p>同样，该<code>cat</code>命令打印（ <em>连接</em> ）一个或多个文件的内容、<code>grep</code>选择与给定模式匹配的文本、<code>sed</code>替换文本模式等。 Unix 命令行具有强大的“管道”概念，它将一个命令的输出作为输入附加到下一个命令，创建一个选择、转换、过滤、排序等管道。 您可以编写复杂的文本和数据处理程序，这些程序基于组合一些精心设计的命令，每个命令都 <em>做一件事，而且做得很好</em> 。</p><h3 id="单一目的与单一职责" tabindex="-1">单一目的与单一职责 <a class="header-anchor" href="#单一目的与单一职责" aria-label="Permalink to &quot;单一目的与单一职责&quot;">​</a></h3><p>乍一看，这看起来像是单一职责原则 (SRP)，对于 SRP 的某些解释，存在一些重叠。但“做好一件事”是一种由外而内的观点； 它具有特定、明确和全面的目的。SRP 是一个由内而外的观点：它是关于代码的组织。</p><p>SRP，用创造这个术语的 Robert C. Martin 的话来说是，[代码]“<a href="https://en.wikipedia.org/wiki/Single-responsibility_principle" target="_blank" rel="noreferrer">应该有一个，而且只有一个，改变的理由</a>。” Wikipedia 文章中的示例是一个生成报告的模块，您应该在其中将报告的内容和格式视为单独的关注点， 它们应该存在于单独的类中，甚至是单独的模块中。 正如我<a href="https://dannorth.net/2021/03/16/cupid-the-back-story/#single-responsibility-principle" target="_blank" rel="noreferrer">在其他地方所说</a>， 根据我的经验，这会产生人为的接缝，最常见的情况是数据的内容和格式一起改变；例如，一个新字段或对某些数据源的更改会影响其内容和您希望显示它的方式。</p><p>另一个常见场景是“UI 组件”，其中 SRP 要求您将组件的呈现和业务逻辑分开。 作为开发人员，让这些人生活在不同的地方会导致将相同字段链接在一起的行政工作。 更大的风险是，这可能是一种过早的优化，会阻止随着代码库的增长而出现的更自然的关注点分离， 以及随着“做好一件事”并且<a href="https://dannorth.net/2022/02/10/cupid-for-joyful-coding/#domain-based-structure" target="_blank" rel="noreferrer">更适合</a>问题空间的域模型的组件的出现。 随着任何代码库的增长，将其分离为合理的子组件的时候到了， 但是可组合性和<a href="https://dannorth.net/2022/02/10/cupid-for-joyful-coding/#domain-based-structure" target="_blank" rel="noreferrer">基于域的结构</a>的属性将更好地指示何时以及如何进行这些结构更改。</p><hr><h2 id="可预测" tabindex="-1">可预测 <a class="header-anchor" href="#可预测" aria-label="Permalink to &quot;可预测&quot;">​</a></h2><p>代码应该做它看起来做的事情，一致且可靠，没有令人不快的意外。这不仅应该是可能的，而且应该很容易确认。从这个意义上说，可预测性是可测试性的概括。</p><p>可预测的代码应该 <em>按预期运行</em> ，并且应该是<em>确定性</em>和<em>可观察</em>的。</p><h3 id="表现如预期" tabindex="-1">表现如预期 <a class="header-anchor" href="#表现如预期" aria-label="Permalink to &quot;表现如预期&quot;">​</a></h3><p>Kent Beck 的<a href="https://www.martinfowler.com/bliki/BeckDesignRules.html" target="_blank" rel="noreferrer">四项简单设计规则中</a>的第一条是代码“通过了所有测试”。 即使没有测试，这也应该是正确的！ 可预测代码的预期行为应该从其结构和命名中显而易见。 如果没有自动化测试来实现这一点，那么编写一些应该很容易。 Michael Feathers 将这些<a href="https://michaelfeathers.silvrback.com/characterization-testing" target="_blank" rel="noreferrer">特性称为测试</a>。 用他的话说：</p><blockquote><p>“当一个系统投入生产时，在某种程度上，它变成了它自己的规范。”——迈克尔·费瑟斯</p></blockquote><p>这不是必需的，我发现有些人认为测试驱动开发是一种信仰，而不是一种工具。 我曾经开发过一个复杂的算法交易应用程序，它的“测试覆盖率”约为 7%。 这些测试分布不均！大部分代码根本没有自动化测试，有些代码有大量复杂的测试，检查细微的错误和边缘情况。 我有信心对大部分代码库进行更改，因为每个组件都只做一件事，并且其行为直接且可预测，因此更改通常很明显。</p><h3 id="确定性" tabindex="-1">确定性 <a class="header-anchor" href="#确定性" aria-label="Permalink to &quot;确定性&quot;">​</a></h3><p>软件每次都应该做同样的事情。即使设计为非确定性的代码（例如随机数生成器或动态计算）也将具有您可以定义的操作或功能界限。 您应该能够预测内存、网络、存储或处理边界、时间边界以及对其他依赖项的期望。</p><p>决定论是一个广泛的话题。出于可预测性的目的，确定性代码应该是<em>健壮</em>的、<em>可靠</em>的和<em>有弹性</em>的。</p><ul><li><strong>稳健性</strong>是我们涵盖的情况的 <em>广度或完整性</em> 。限制和边缘情况应该是显而易见的。</li><li>在我们涵盖的情况下，可靠性 <em>按预期运行</em> 。我们每次都应该得到相同的结果。</li><li><strong>弹性</strong>是我们处理未覆盖的情景的能力； <em>输入或操作环境中的意外扰动</em> 。</li></ul><h3 id="可观察" tabindex="-1">可观察 <a class="header-anchor" href="#可观察" aria-label="Permalink to &quot;可观察&quot;">​</a></h3><p>代码在<a href="https://en.wikipedia.org/wiki/Observability" target="_blank" rel="noreferrer">控制理论的意义上</a>应该是可观察的：我们可以从它的输出推断它的内部状态。 这只有在我们设计时才有可能。一旦几个组件交互，尤其是异步交互，就会出现紧急行为和非线性后果。</p><p>从一开始就检测代码意味着我们可以获得有价值的数据来了解其运行时特性。我描述了一个四阶段模型——有两个奖励阶段！——像这样：</p><ol><li><strong>说明</strong>是您的软件说明它在做什么。</li><li><strong>遥测</strong>使这些信息可用，无论是通过拉（请求）还是推送（发送消息）；“远距离测量”。</li><li><strong>监控</strong>正在接收仪器并使其可见。</li><li><strong>警报</strong>是对监控的数据或数据中的模式做出反应。 奖励：</li><li><strong>预测</strong>是使用这些数据在事件发生之前对其进行预测。</li><li><strong>适应</strong>是动态地改变系统，以抢占或从预测的扰动中恢复。</li></ol><p>大多数软件甚至都没有通过第 1 步。有些工具会拦截或改变正在运行的系统以增加洞察力，但这些工具永远不如为应用程序设计的故意仪表。</p><hr><h2 id="惯用语" tabindex="-1">惯用语 <a class="header-anchor" href="#惯用语" aria-label="Permalink to &quot;惯用语&quot;">​</a></h2><p>每个人都有自己的编码风格。无论是空格还是制表符、缩进大小、变量命名约定、大括号或圆括号的位置、源文件中的代码布局，还是无数其他可能性。 在此之上，我们可以对库、工具链、生存路径、甚至版本控制注释样式或提交粒度的选择进行分层。（你确实使用版本控制，不是吗？）</p><p>这会给使用不熟悉的代码增加显着的<a href="https://en.wikipedia.org/wiki/Cognitive_load" target="_blank" rel="noreferrer">额外认知负担</a>。 除了理解问题域和解决方案空间之外，您还必须解释其他人的意思，以及他们的决定是经过深思熟虑的和上下文相关的，还是任意的和习惯性的。</p><p><strong>最大的编程特质是同理心</strong>。</p><ul><li>同情你的用户；</li><li>对支持人员的同理心；</li><li>对未来开发者的同理心；</li><li>任何人都可能成为未来的你。</li></ul><p>编写“人类可以理解的代码”意味着为<em>其他人</em>编写代码。这就是惯用代码的含义。</p><p>在这种情况下，您的目标受众是：</p><ul><li>熟悉该语言、它的库、它的工具链和它的生态系统</li><li>了解软件开发的经验丰富的程序员</li><li>努力完成工作！</li></ul><h3 id="语言习语" tabindex="-1">语言习语 <a class="header-anchor" href="#语言习语" aria-label="Permalink to &quot;语言习语&quot;">​</a></h3><p>代码应该符合语言的习惯用法。一些语言对代码的外观有强烈的看法，这使得评估代码的惯用程度变得容易。 其他人不那么固执己见，这让你有责任“选择一种风格”然后坚持下去。Go 和 Python 是固执己见的语言的两个例子。</p><p>Python 程序员使用术语“pythonic”来描述惯用代码。 如果您使用 Python REPL 或从 shell运行，就会出现一个美妙的<a href="https://en.wikipedia.org/wiki/Easter_egg_(media)" target="_blank" rel="noreferrer">复活节彩蛋。</a> 它打印了一个名为“Python 之禅”的编程格言列表，其中包括这一行， 抓住了惯用代码的精神：“应该有一种——最好只有一种——明显的方式来做到这一点。”<code>import this\`\`python -m this</code></p><p>Go 语言附带了一个名为的代码格式化程序<code>gofmt</code>，它使所有源代码看起来都一样。 这一下子消除了关于缩进、大括号放置或其他语法怪癖的任何分歧。 这意味着您在库文档或教程中看到的任何代码示例看起来都是一致的。 他们甚至有一个名为<a href="https://go.dev/doc/effective_go" target="_blank" rel="noreferrer">Effective Go</a>的文档，展示了语言定义之外的惯用 Go。</p><p>光谱的另一端是 Scala、Ruby、JavaScript 和古老的 Perl 等语言。 这些语言是故意的多范式；Perl 创造了首字母缩略词 TIMTOWTDI——“有不止一种方法可以做到”——发音为“Tim Toady”。 您可以在其中大多数中编写函数式、过程式或面向对象的代码，这会从您所知道的任何一种语言中创建一个浅薄的学习曲线。</p><p>对于处理一系列值这样简单的事情，这些语言中的大多数都允许您：</p><ul><li>使用迭代器</li><li>使用索引 for 循环</li><li>使用条件 while 循环</li><li>使用带有收集器的函数管道（“map-reduce”）</li><li>写一个尾递归函数</li></ul><p>这意味着在任何不平凡的代码大小中，您都可能会找到其中每一个的示例，通常是相互结合的。 同样，这一切都会增加认知负担，影响您思考手头问题的能力，增加不确定性并减少快乐。</p><p>代码习语出现在所有粒度级别：命名函数、类型、参数、模块；代码布局；模块结构；工具的选择；依赖项的选择；你如何管理依赖关系；等等。</p><p>无论您的技术堆栈处于自以为是的范围内，如果您花时间学习该语言的习语、它的生态系统、它的社区和它的首选风格，那么您编写的代码将会更有同理心和快乐。</p><p>您对一项技术的学习曲线可能比您在其中编写的任何代码都短，因此抵制编写<em>现在对您</em>来说很好读的代码的冲动很重要， 因为那个人不会存在很长时间！确信您正在编写惯用代码的唯一方法是花时间学习惯用语。</p><h3 id="地方习语" tabindex="-1">地方习语 <a class="header-anchor" href="#地方习语" aria-label="Permalink to &quot;地方习语&quot;">​</a></h3><p>当一种语言在惯用风格或几种替代方案方面没有达成共识时，由您和您的团队决定“好的”是什么样的，并引入约束和指导方针以鼓励一致性。 这些约束可以很简单，例如 IDE 中的共享代码格式化规则、用于 [检查](<a href="https://en.wikipedia.org/wiki/Lint_(software)" target="_blank" rel="noreferrer">https://en.wikipedia.org/wiki/Lint_(software)</a> 和批评代码的“构建 cop”工具，以及就标准工具链达成一致。</p><p>架构决策记录或 ADR 是记录您对风格和习语的选择的好方法。与任何其他架构讨论相比，这些都是“重要的技术决策”。</p><hr><h2 id="基于领域" tabindex="-1">基于领域 <a class="header-anchor" href="#基于领域" aria-label="Permalink to &quot;基于领域&quot;">​</a></h2><p>我们编写软件来满足需要。这可能是具体的和情境化的，也可能是笼统的和影响深远的。 不管它的目的是什么，代码都应该用问题域的语言来表达它正在做什么，以最小化你写的东西和它所做的事情之间的认知距离。 这不仅仅是“使用正确的词”。</p><h3 id="基于领域的语言" tabindex="-1">基于领域的语言 <a class="header-anchor" href="#基于领域的语言" aria-label="Permalink to &quot;基于领域的语言&quot;">​</a></h3><p>编程语言及其库充满了计算机科学的结构，如哈希映射、链接列表、树集、数据库连接等。它们具有包括整数、字符、布尔值的基本类型。 您可以将某人的姓声明为一个<code>string[30]</code>，这很可能是它的存储方式，但定义一个<code>Surname</code>类型将更具意图。 它甚至可能具有与姓氏相关的操作、属性或约束。 银行软件中的许多细微错误是由于将金额表示为浮点值；有经验的金融软件程序员会用<code>Currency</code>和<code>Amount</code>定义一个<code>Money</code>类型，它本身就是一个复合类型。</p><p>正确命名类型和操作不仅仅是为了捕捉或防止错误，而是为了让代码中的解决方案空间更容易表达和导航。 这是我对“<a href="https://www.oreilly.com/library/view/97-things-every/9780596809515/" target="_blank" rel="noreferrer">每个程序员应该知道的 97 件事</a>”的贡献，作为“领域语言中的代码”。</p><p>领域驱动代码成功的一个标准是，不经意的观察者无法判断人们是在讨论代码还是在讨论领域。 我曾经在一个电子交易系统中遇到过这种情况，一位金融分析师正在与两名程序员讨论复杂的交易定价逻辑。 我以为他们在讨论定价规则，但他们指着一屏代码，分析师正在通过定价算法与程序员交谈，这是代码如何逐行读取的！ 问题域和解决方案代码之间唯一的认知距离是一些语法标点符号！</p><h3 id="基于域的结构" tabindex="-1">基于域的结构 <a class="header-anchor" href="#基于域的结构" aria-label="Permalink to &quot;基于域的结构&quot;">​</a></h3><p>使用基于域的语言很重要，但如何构建代码也同样重要。 许多框架都提供了一个“骨架项目”，其目录布局和存根文件旨在帮助您快速入门。 这会在您的代码上强加一个与您正在解决的问题无关<em>的先验结构</em>。</p><p>相反，代码的布局——目录名称、子文件夹和同级文件夹的关系、相关文件的分组和命名——应该尽可能地反映问题域。</p><p>应用程序框架<a href="https://rubyonrails.org" target="_blank" rel="noreferrer">Ruby on Rails</a>在 2000 年代初期通过将其 <a href="https://guides.rubyonrails.org/getting_started.html%23creating-the-blog-application" target="_blank" rel="noreferrer">构建</a> 到其工具中而普及了这种方法，Rails 的广泛采用意味着许多后来的框架都复制了这个想法。 CUPID 与语言和框架无关，但 Rails 提供了一个有用的案例研究来理解基于域的结构和基于框架的结构之间的区别。</p><p>下面是生成的 Rails 应用程序的部分目录布局，重点关注开发人员将花费大部分时间的目录 (<code>app</code>)。 在撰写本文时，完整的框架运行到大约 50 个目录，其中包含 60 个文件。</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">app</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">├──</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> assets</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">│  </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> ├──</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> config</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">│  </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> ├──</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> images</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">│  </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> └──</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> stylesheets</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">├──</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> channels</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">│  </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> └──</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> application_cable</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">├──</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> controllers</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">│  </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> └──</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> concerns</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">├──</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> helpers</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">├──</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> javascript</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">│  </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> └──</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> controllers</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">├──</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> jobs</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">├──</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> mailers</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">├──</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> models</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">│  </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> └──</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> concerns</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">└──</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> views</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">    └──</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> layouts</span></span></code></pre></div><p>想象一下，这将是一个医院管理应用程序，其中有一个病人记录部分。这种布局表明我们至少需要：</p><ul><li>一个 <em>模型</em> ，它映射到某处的数据库</li><li>一个 <em>视图</em> ，在屏幕上呈现患者记录</li><li>一个 <em>控制器</em> ，在视图和模型之间进行调解</li></ul><p>然后是 <em>helpers</em> 、<em>assets</em>和其他几个框架概念的范围， 例如<em>模型关注点</em>或 <em>控制器关注点</em> 、<em>邮件</em>程序、 <em>作业</em> 、 <em>通道</em> ，以及可能与 Ruby 控制器一起使用的 JavaScript 控制器。 这些人工制品中的每一个都存在于一个单独的目录中，即使它们在语义上是紧密集成的。</p><p>对患者记录管理的任何重大更改都可能涉及分散在代码库中的代码。 单一职责的 SOLID 原则说视图代码应该与控制器代码分开，并且像 Rails 这样的框架将其解释为意味着将它们放在完全不同的位置。 这增加了认知负荷，降低了凝聚力，并增加了进行产品更改的努力。 正如我<a href="https://dannorth.net/2022/02/10/cupid-for-joyful-coding/#single-purpose" target="_blank" rel="noreferrer">之前所讨论的</a>， 这种意识形态约束会使工作更加困难，代码库的乐趣也会降低。</p><p>我们仍然需要模型、视图和控制器等人工制品，无论我们以何种方式布置代码， 但按类型对它们进行分组不应形成主要结构。相反，代码库的顶层应该显示医院管理的主要用例； 也许<code>patient_history</code>,<code>appointments</code>,<code>staffing</code>和<code>compliance</code>.</p><p>对代码结构采用基于域的方法可以很容易地理解代码的用途，并且可以轻松导航到任何比“使按钮变成浅蓝色”更复杂的地方。</p><h3 id="基于域的边界" tabindex="-1">基于域的边界 <a class="header-anchor" href="#基于域的边界" aria-label="Permalink to &quot;基于域的边界&quot;">​</a></h3><p>当我们按照我们想要的方式构建代码并按照我们想要的方式命名时，模块边界就变成了域边界，部署就变得简单了。 将组件部署为单个工件所需的一切都在一起，因此我们可以将域边界与部署边界对齐，并部署有凝聚力的业务组件和服务。 无论您将您的产品或服务打包为单个单体、许多小型微服务，还是介于两者之间的任何地方，这种一致性都降低了您的生存路径的复杂性， 并降低了您忘记某些东西或包含来自不同环境的人工制品或不同的子系统。</p><p>这并不限制我们使用单一的、扁平的、顶级的代码结构。 域可以包含子域；组件可以包含子组件；部署可以在对您的变更和风险状况有意义的任何粒度级别进行。 将代码边界与域边界对齐可以使所有这些选项更易于推理和管理。</p><hr><h2 id="结论性想法" tabindex="-1">结论性想法 <a class="header-anchor" href="#结论性想法" aria-label="Permalink to &quot;结论性想法&quot;">​</a></h2><p>我相信拥有更多这些属性的代码——可组合性、Unix 哲学、可预测性，或者是惯用的或基于域的——比不具备这些属性的代码更令人愉悦。 虽然我独立评估每个特征，但我发现它们是相辅相成的。</p><p>既可组合又全面的代码——做好一件事——就像一个可靠的朋友。即使您以前从未见过惯用代码，也感觉很熟悉。 可预测的代码为您提供了空闲周期来专注于其他地方的惊喜。基于领域的代码最小化了从需求到解决方案的认知距离。 将代码移向这些属性中的任何一个的“中心”会比你发现的更好。</p><p>因为 CUPID 是一个 <a href="https://en.wikipedia.org/wiki/Backronym" target="_blank" rel="noreferrer">backronym</a>，所以每个字母我都有几个候选者。 我之所以选择这五个，是因为它们以某种方式感到“基础”；我们可以从中得出所有其他候选属性。 未来的文章将探讨一些没有入选的候选属性，并看看它们是如何成为编写 CUPID 软件的自然结果。</p><p>我很想听听人们与 CUPID 的冒险经历。我已经听说有团队使用这些属性来评估他们的代码，并制定清理遗留代码库的策略，我迫不及待地想听到经验报告和案例研究。 与此同时，我想更深入地了解 CUPID，依次探索每个属性，看看还有什么隐藏在显而易见的地方。</p><hr><ol><li>我建议任何参与软件开发的人，而不仅仅是程序员，阅读这篇短文。这是一篇深刻而优美的文字。 <a href="https://dannorth.net/2022/02/10/cupid-for-joyful-coding/#fnref:1" target="_blank" rel="noreferrer">↩︎</a></li><li>在 1970 年代，人类学家和基督教传教士（传教士的观察者）保罗·G·希伯特（Paul G. Hiebert）使用有界和中心集的数学概念来对比“有界”社区，这些社区通过谁在谁在外面的规则来定义自己，与“中心”社区一起，他们通过一组核心价值观来定义自己，人们更接近或远离这些核心价值观，但从不“外部”。 <a href="https://dannorth.net/2022/02/10/cupid-for-joyful-coding/#fnref:2" target="_blank" rel="noreferrer">↩︎</a></li><li>单一职责的定义是代码应该有“一个且只有一个改变的理由”，例如，你应该将 UI 代码与业务逻辑分开。这个约束不仅很容易反驳——因为出于安全性、合规性、上游或下游依赖性、操作特性等原因，即使是一行代码也可能需要更改，而且我认为它是一个任意约束往往是过早的隔离，带来负面后果。 <a href="https://dannorth.net/2022/02/10/cupid-for-joyful-coding/#fnref:3" target="_blank" rel="noreferrer">↩︎</a></li><li>除此之外，Unix 操作系统的设计还有一个优雅的简洁性：一切都是文件；一切要么是文字，要么不是文字；我们通过一系列转换处理文本来构建整个程序。 <a href="https://dannorth.net/2022/02/10/cupid-for-joyful-coding/#fnref:4" target="_blank" rel="noreferrer">↩︎</a></li><li>Ruby 在这里可能是一个异类，因为肯定存在“Ruby 美学”，并且很多人都写过“<a href="https://www.freecodecamp.org/news/idiomatic-ruby-writing-beautiful-code-6845c830c664/" target="_blank" rel="noreferrer">惯用的 Ruby</a> ”，但这仍然是个人分享他们喜欢的编程风格，而不是社区固有的任何东西。 <a href="https://dannorth.net/2022/02/10/cupid-for-joyful-coding/#fnref:5" target="_blank" rel="noreferrer">↩︎</a></li><li>架构决策记录由 Michael Nygard 于 2011 年<a href="https://cognitect.com/blog/2011/11/15/documenting-architecture-decisions" target="_blank" rel="noreferrer">首次提出</a>，此后<a href="https://adr.github.io" target="_blank" rel="noreferrer">一直在发展</a>。 <a href="https://dannorth.net/2022/02/10/cupid-for-joyful-coding/#fnref:6" target="_blank" rel="noreferrer">↩︎</a></li><li>关于框架应该为“原始”项目的开发人员施加多少脚手架和生成的样板，还有一个完整的其他讨论，这超出了本文的范围。 <a href="https://dannorth.net/2022/02/10/cupid-for-joyful-coding/#fnref:7" target="_blank" rel="noreferrer">↩︎</a></li></ol><hr><ul><li><a href="https://dannorth.net/2022/02/10/cupid-for-joyful-coding/" target="_blank" rel="noreferrer">https://dannorth.net/2022/02/10/cupid-for-joyful-coding/</a></li></ul><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>1 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>`,117)]))}const f=a(s,[["render",n]]);export{k as __pageData,f as default};
