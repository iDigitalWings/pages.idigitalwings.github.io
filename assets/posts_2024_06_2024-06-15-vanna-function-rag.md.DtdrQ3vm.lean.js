import{_ as n,a as t,af as s,o as i}from"./chunks/framework.C87LdZyP.js";const o="/assets/299578797887291.xPNXR_e6.png",r="/assets/300516172258458.tPaoeMMk.png",e="/assets/303433445154875.BAje87KO.png",p="/assets/276325621029250.D4dU2iZv.png",l="/assets/276244366171750.CN58LkvB.png",c="/assets/276294059628375.BemD20ha.png",g="/assets/276750328064958.nQVH66nt.png",h="/assets/277208640445000.CKtACyyU.png",d="/assets/277349443162875.Dcv_QIAO.png",A="/assets/277424426711916.DU5gMjV4.png",u="/assets/277476163761208.BIR7GG8v.png",m="/assets/277523817399958.DFnWPxBY.png",L=JSON.parse('{"title":"VannaAI 最新特性：函数 RAG 和智能体","description":"","frontmatter":{"title":"VannaAI 最新特性：函数 RAG 和智能体","date":"2024-06-15 19:00:00","tags":["llm-tools","vanna.ai"],"category":["AI"]},"headers":[],"relativePath":"posts/2024/06/2024-06-15-vanna-function-rag.md","filePath":"posts/2024/06/2024-06-15-vanna-function-rag.md","lastUpdated":1721617651000}'),k={name:"posts/2024/06/2024-06-15-vanna-function-rag.md"};function G(R,a,_,f,b,F){return i(),t("div",null,a[0]||(a[0]=[s('<div class="admonition abstract"><p class="admonition-title">abstract</p><p>Function RAG（函数检索增强生成）：Vanna.AI 的这个新功能可以增强 SQL 生成的一致性和确定性，满足用户的大量请求（高性能）。</p></div><p>本文在 RAG-to-SQL 的基础上，介绍了：</p><ul><li>什么是 <strong>函数RAG</strong></li><li>函数RAG的<strong>特点</strong></li><li><strong>工具和智能体</strong>的结合</li><li><strong>如何使用</strong>函数RAG</li><li>函数RAG的<strong>使用场景</strong>分析和<strong>启发</strong></li></ul><p>!!! article 阅读更多</p><ul><li><a href="./2024-06-13-vanna-ai">VannaAI：RAG+AI 生成 SQL 使用和Prompt解析</a></li><li><a href="./2024-06-14-vanna-ai-training">训练 Vanna RAG-to-SQL 模型来适配企业级数据库</a> !!!</li></ul><h2 id="函数rag-function-rag-是什么" tabindex="-1">函数RAG(Function RAG) 是什么 <a class="header-anchor" href="#函数rag-function-rag-是什么" aria-label="Permalink to &quot;函数RAG(Function RAG) 是什么&quot;">​</a></h2><p>上一篇讲训练的文章提到，VannaAI 经典训练方法 <strong>Question-SQL</strong> 的方式，而 <strong>Function RAG</strong> 就是这种方式的升级， 讲训练转换为<strong>可调用的模板</strong>，这个可调用模板称之为<strong>函数</strong>。</p><p>在使用<strong>函数RAG</strong>的时候，LLM仅决定使用哪个函数（模板）、以及函数（模板）的参数是什么，这样就保证了<strong>输出的一致性</strong>， 同时能显著<strong>加快</strong>SQL生成的过程。</p><p>下面简单画了个架构图， 能清楚的看到函数RAG的执行过程：</p><p><img src="'+o+'" alt="Vanna函数RAG架构"></p><h2 id="函数rag的特点" tabindex="-1">函数RAG的特点 <a class="header-anchor" href="#函数rag的特点" aria-label="Permalink to &quot;函数RAG的特点&quot;">​</a></h2><p>函数RAG的特点和优点也是我们前面讲到他解决的问题：</p><ul><li>基于模板生成SQL：大模型保证SQL和用户查询相关，模板保证SQL的<strong>准确性</strong>，和执行的<strong>速度</strong>。</li><li><strong>增强安全性</strong>：函数RAG不仅能防止<strong>提示注入</strong>等安全问题，还可以预设模板嵌入权限等逻辑保障<strong>数据安全</strong>。</li><li><strong>用户特定的查询</strong>：可以在查询中嵌入用户信息，而不必担心数据泄露，执行个性化问题：比如查询： <ul><li>我最近的订单有哪些？</li><li>我这个月的考勤？</li><li>我部门的业绩？</li></ul></li><li>集成图表代码的生成：前面提到 Vanna.AI 生成的图表太单一，使用 函数RAG 嵌入SQL对应的可视化代码，能够达到<strong>可定制的图表展示</strong>。</li><li>多语言支持：函数RAG 的架构设计为被各种语言（JS,Java等）集成提供了可能性</li></ul><h3 id="智能体和工具集成" tabindex="-1"><strong>智能体和工具集成</strong> <a class="header-anchor" href="#智能体和工具集成" aria-label="Permalink to &quot;**智能体和工具集成**&quot;">​</a></h3><p>我看了下源码，Vanna.AI 正在很好的抽取和模块化核心逻辑，配合 函数RAG的功能，我们能很方便的吧 VannaAI 集成响应的工具调用，实现数据应用的智能体。</p><div class="admonition note"><p class="admonition-title">为什么基于 Function</p><p>在没有推出 Function RAG 的时候，其实也可以改造 Vanna 来实现工具调用，但是基于对话式的框架，缺少<strong>核心元数据</strong>的支持， 实现该功能对 Vanna 的架构改变较大，做的工作稍多。而在 Function RAG 的框架内，我们很容易做扩展来实现该能力。</p></div><p>详细解释一点，就比如我们去年文章展示的 BI 增加工具调用一样：</p><p><img src="'+r+'" alt="《万物皆可LLM》"></p><p>基于《AIGC时代的用户体验和接口设计》的交互规范，我们可以稍微改造一下就让其初步具备 Agent 的能力：</p><p><img src="'+e+'" alt="Vanna.AI扩展工具示例"></p><p>这个的优点就是基于 「函数」 来定制不同的<strong>可能的行为动作</strong>。因为除了单纯的看数据，大部分的查询我们都是有使用数据的意图的。</p><p>比如：当你查询你本周的工作日报时，可能的动作就是**「发送工作周报」**。</p><div class="admonition note"><p class="admonition-title">note</p><p>这个章节介绍的想法功能 Vanna.AI 还没有实现，不过如果其团队的激情不减，一两个月内大家应该就能见到相关功能的体验版。</p></div><h2 id="函数rag使用过程" tabindex="-1">函数RAG使用过程 <a class="header-anchor" href="#函数rag使用过程" aria-label="Permalink to &quot;函数RAG使用过程&quot;">​</a></h2><p>下面展示下 「函数RAG」的使用过程。</p><p>VannaAI 界面山点击 <code>Functions</code> 菜单，可以看到当前已经创建的 Functions，如果没有的话可以点击 <code>New</code> 来新建：</p><p><img src="'+p+'" alt="VannaAI Functions"></p><p>新建的过程也很简单，直接输入你的问题，等待 Vanna.AI 的执行，比如我们「有多少个艺术家」：</p><p><img src="'+l+'" alt=""></p><p>点击 「Yes, create function」，就可以创建一个函数。下图展示函数创建的结果，包含：</p><ul><li>唯一的函数名称</li><li>函数的问题模板</li><li>函数的参数（这个例子没有）</li></ul><p><img src="'+c+'" alt=""></p><p>下面我们创建另外一个函数，提问： <code>销量最高的五个国家</code>，可以看到创建的函数里面多了一个 <code>limit</code> 的参数：</p><p><img src="'+g+'" alt=""></p><p>再次提问：<code>销量最高的10个国家</code>，可以看到 Vanna 执行了刚刚创建的函数，并且把参数设置为 <code>10</code>，直接执行了 SQL， 而且我们可以明显感到执行的速比BI之前快了很多。</p><p><img src="'+h+'" alt=""></p><h2 id="ui-的局限" tabindex="-1">UI 的局限 <a class="header-anchor" href="#ui-的局限" aria-label="Permalink to &quot;UI 的局限&quot;">​</a></h2><p>当我提问 <code>最近20年开票最多的三个客户</code> 来创建函数时，</p><p><img src="'+d+'" alt=""></p><p>创建的函数只有一个 <code>years</code> 参数，并没有 <code>limit</code> 这个参数。</p><p><img src="'+A+'" alt=""></p><p>重新执行查询 <code>最近10年开票最多的五个客户</code>，发现匹配到了函数，参数也修改了，但是只修改了一个。</p><p><img src="'+u+'" alt=""></p><p>查看 SQL 也发现并没有把 <code>五个客户</code> 的条件给放进去。</p><p><img src="'+m+'" alt=""></p><p>遇到这种情况，我们的解决方案也很简单，使用<strong>代码创建函数</strong>即可，你可以不依赖LLM，更灵活和准确的控制函数的构成：</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">vn.create_function(</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">question</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">sql</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">plotly_code</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">)</span></span></code></pre></div><h2 id="何时使用" tabindex="-1">何时使用 <a class="header-anchor" href="#何时使用" aria-label="Permalink to &quot;何时使用&quot;">​</a></h2><h3 id="类似问题查询" tabindex="-1">类似问题查询 <a class="header-anchor" href="#类似问题查询" aria-label="Permalink to &quot;类似问题查询&quot;">​</a></h3><p>最终用户经常会询问类似问题，那么函数 RAG 可以很好提升效率和准确率。</p><h3 id="限制用户查询" tabindex="-1">限制用户查询 <a class="header-anchor" href="#限制用户查询" aria-label="Permalink to &quot;限制用户查询&quot;">​</a></h3><p>如果产品期望限制用户的查询，只允许用户查询经过批准和确认的特定查询及分析。 此时 Function RAG 是能够确保运行特定查询的好方法。</p><h3 id="限制用户查询数据范围" tabindex="-1">限制用户查询数据范围 <a class="header-anchor" href="#限制用户查询数据范围" aria-label="Permalink to &quot;限制用户查询数据范围&quot;">​</a></h3><p>传统 Text 2 SQL 无法应用到企业生产<strong>最重要</strong>的问题就是「大模型的不确定性」和**「无法限制数据范围」**。</p><p>而 FunctionRAG 就能很好的解决这两个问题，他可以保证用户最终能看到<strong>正确的数据</strong>。</p><h3 id="提高速度" tabindex="-1">提高速度 <a class="header-anchor" href="#提高速度" aria-label="Permalink to &quot;提高速度&quot;">​</a></h3><p>如果你的场景查询范围有限，复核上述特点，那么强烈建议你使用 FunctionRAG，因为他可以极大提升运行速度。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>RAG-to-SQL 为基于大模型的 SQL 生成（或者说是 Text-to-SQL）开辟了新的领域，那 Function RAG 就像是 是这个新领域的一条新道路。</p><p>而且 <strong>LLM -&gt; RAG -&gt; Function</strong> 的产品功能路线和设计思路也给了我们极大的启发， 让普通的东西经过优雅的设计绽放不一样的色彩。</p><p>!!! article 阅读更多</p><ul><li><a href="./2024-06-13-vanna-ai">VannaAI：RAG+AI 生成 SQL 使用和Prompt解析</a></li><li><a href="./2024-06-14-vanna-ai-training">训练 Vanna RAG-to-SQL 模型来适配企业级数据库</a> !!!</li></ul>',62)]))}const q=n(k,[["render",G]]);export{L as __pageData,q as default};
