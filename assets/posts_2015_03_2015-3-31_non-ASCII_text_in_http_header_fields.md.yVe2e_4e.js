import{_ as e,a as t,o as s,aj as i}from"./chunks/framework.Ba_Ek9Jm.js";const g=JSON.parse('{"title":"non-ASCII Text in HTTP Header Fields","description":"","frontmatter":{"title":"non-ASCII Text in HTTP Header Fields","date":"2015-03-31T00:00:00.000Z","tags":["js","http"]},"headers":[],"relativePath":"posts/2015/03/2015-3-31_non-ASCII_text_in_http_header_fields.md","filePath":"posts/2015/03/2015-3-31_non-ASCII_text_in_http_header_fields.md","lastUpdated":1718193786000}'),a={name:"posts/2015/03/2015-3-31_non-ASCII_text_in_http_header_fields.md"},n=i('<p>今天程序出现下面问题，才知道原来HttpHeader里面不能放<code>non ascii</code>的内容．</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span>DOMException: Failed to execute &#39;setRequestHeader&#39; on &#39;XMLHttpRequest&#39;: &#39;{&quot;and&quot;:[{&quot;field&quot;:&quot;recordType&quot;,&quot;value&quot;:&quot;数据一&quot;}]}&#39; is not a valid HTTP header field value.</span></span></code></pre></div><p>网络上有关于此的详细解释，贴在文章末尾，有兴趣的看一下．</p><p>这里我的解决方法是客户端对其进行<code>urlEndcode</code>，然后服务端对<code>urlDecode</code>．</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">@headers.filter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> encodeURI</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(@headers.filter) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> @headers.filter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> @headers.filter.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">indexOf</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;{&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">0</span></span></code></pre></div><div class="language-groovy vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">groovy</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">URLDecoder.</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">decode(filter)</span></span></code></pre></div><p>当然，这只能使用于客户端服务端都能控制的情况，不然的话只能把 non ascii　的内容放到url,或者http body里面了．</p><p>参考：</p><ul><li><a href="https://www.ietf.org/rfc/rfc2047.txt" target="_blank" rel="noreferrer">https://www.ietf.org/rfc/rfc2047.txt</a></li><li><a href="https://tools.ietf.org/html/rfc5987" target="_blank" rel="noreferrer">https://tools.ietf.org/html/rfc5987</a></li><li><a href="https://greenbytes.de/tech/webdav/draft-reschke-http-jfv-00.html" target="_blank" rel="noreferrer">https://greenbytes.de/tech/webdav/draft-reschke-http-jfv-00.html</a></li><li><a href="http://stackoverflow.com/questions/4400678/http-header-should-use-what-character-encoding" target="_blank" rel="noreferrer">http://stackoverflow.com/questions/4400678/http-header-should-use-what-character-encoding</a></li></ul><hr><div style="text-align:center;color:#00000099;font-size:14px;">END</div>',11),r=[n];function l(h,d,p,o,c,k){return s(),t("div",null,r)}const f=e(a,[["render",l]]);export{g as __pageData,f as default};
