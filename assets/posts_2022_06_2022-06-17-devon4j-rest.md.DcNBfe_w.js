import{_ as s,a as i,o as a,aj as e}from"./chunks/framework.Ba_Ek9Jm.js";const A=JSON.parse('{"title":"Devon4j: REST","description":"","frontmatter":{"title":"Devon4j: REST","date":"2022-06-17T00:00:00.000Z","tags":["devon4j"],"category":["架构"]},"headers":[],"relativePath":"posts/2022/06/2022-06-17-devon4j-rest.md","filePath":"posts/2022/06/2022-06-17-devon4j-rest.md","lastUpdated":1718173059000}'),t={name:"posts/2022/06/2022-06-17-devon4j-rest.md"},n=e(`<p>REST (<a href="https://en.wikipedia.org/wiki/Representational_state_transfer" target="_blank" rel="noreferrer">REpresentational State Transfer</a>) 是一种比SOAP更轻量级的<strong>服务</strong>互操作协议。 但是，它不是真正的标准，可能会引起混淆（请参阅 REST 哲学）。 因此，我们在这里定义最佳实践来指导您。</p><h2 id="urls" tabindex="-1">URLs <a class="header-anchor" href="#urls" aria-label="Permalink to &quot;URLs&quot;">​</a></h2><p>URL 不区分大小写。因此，我们遵循最佳实践，仅使用带有连字符的小写字母来分隔单词。对于 REST 中的操作，我们区分以下类型的 URL：</p><ul><li><em>集合URL</em>是通过附加<strong>集合名称</strong>从其余服务 URL 构建的。这通常是实体的名称。此类 URL 标识此类型的所有元素的整个集合。例子：<code>https://mydomain.com/myapp/services/rest/mycomponent/v1/myentity</code></li><li><em>元素URL</em>是通过附加<strong>元素 ID</strong> 从集合 URL 构建的。它标识集合中的单个元素（实体）。例子：<code>https://mydomain.com/myapp/services/rest/mycomponent/v1/myentity/42</code></li></ul><p>要遵循 KISS，请避免使用复数形式（<code>…/productmanagement/v1/products</code>vs.<code>…/productmanagement/v1/product/42</code>）。 始终使用单数形式并避免混淆（不存在单数的极少数情况除外）。</p><p>REST URL 方案非常适合<a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete" target="_blank" rel="noreferrer">CRUD</a>操作。 对于业务操作（处理、计算、高级搜索等），我们只需将集合 URL 附加到业务操作的名称即可。 然后我们可以为业务操作<code>POST</code>输入并返回结果。例子：<code>https://mydomain.com/myapp/services/rest/mycomponent/v1/myentity/search</code></p><h2 id="http-方法" tabindex="-1">HTTP 方法 <a class="header-anchor" href="#http-方法" aria-label="Permalink to &quot;HTTP 方法&quot;">​</a></h2><p>下表定义了 HTTP 方法（动词）及其含义：</p><p>表 33. HTTP 方法的使用</p><table tabindex="0"><thead><tr><th><strong>HTTP 方法</strong></th><th><strong>意义</strong></th></tr></thead><tbody><tr><td><code>GET</code></td><td>读取数据（无状态）。</td></tr><tr><td><code>PUT</code></td><td>创建或更新数据。</td></tr><tr><td><code>POST</code></td><td>处理数据。</td></tr><tr><td><code>DELETE</code></td><td>删除实体。</td></tr></tbody></table><p>另请注意，对于（大）批量删除，您可能会被迫使用<code>POST</code>，而不是<code>DELETE</code>根据 HTTP 标准<code>DELETE</code>必须没有有效负载并且 URL 的长度受到限制。</p><p>有关<strong>集合URL</strong>和<strong>元素URL</strong> 的 HTTP 方法的一般建议，请参阅<a href="http://en.wikipedia.org/wiki/Representational_State_Transfer%23Applied_to_web_services" target="_blank" rel="noreferrer">REST@wikipedia</a>。</p><h2 id="http-状态码" tabindex="-1">HTTP 状态码 <a class="header-anchor" href="#http-状态码" aria-label="Permalink to &quot;HTTP 状态码&quot;">​</a></h2><p>此外，我们定义了如何正确使用 REST 服务的 HTTP 状态代码。通常，<strong>4xx</strong> 代码对应于客户端的错误，<strong>5xx</strong> 代码对应于服务器端的错误。</p><p>表 34. HTTP 状态码的使用</p><table tabindex="0"><thead><tr><th><strong>HTTP 代码</strong></th><th><strong>含义</strong></th><th><strong>响应</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>200</td><td>OK</td><td>请求的结果</td><td>GET 成功的结果</td></tr><tr><td>204</td><td>无内容</td><td><em>none</em></td><td>POST、DELETE 或 PUT 成功的结果，结果为空（返回无效）</td></tr><tr><td>400</td><td>错误的请求</td><td>错误详情</td><td>HTTP 请求无效（解析错误，验证失败）</td></tr><tr><td>401</td><td>未经授权</td><td><em>none</em></td><td>身份验证失败</td></tr><tr><td>403</td><td>禁止的</td><td><em>none</em></td><td>授权失败</td></tr><tr><td>404</td><td>未找到</td><td><em>none</em></td><td>服务 URL 错误或请求的资源不存在</td></tr><tr><td>500</td><td>服务器错误</td><td>错误代码，UUID</td><td>发生内部服务器错误，如果出现异常，请参阅[REST 异常处理]</td></tr></tbody></table><h2 id="jax-rs" tabindex="-1">JAX-RS <a class="header-anchor" href="#jax-rs" aria-label="Permalink to &quot;JAX-RS&quot;">​</a></h2><p>为了实现 REST 服务，我们使用<a href="https://jax-rs-spec.java.net/" target="_blank" rel="noreferrer">JAX-RS</a>标准。 作为有效负载编码，我们推荐使用Jackson的 JSON 绑定。 要实现 REST 服务，您只需添加 JAX-RS 注释。这是一个简单的：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">ApplicationScoped</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Path</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;/imagemanagement/v1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Consumes</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(MediaType.APPLICATION_JSON)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Produces</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(MediaType.APPLICATION_JSON)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> ImagemanagementRestService</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Inject</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  private</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Imagemanagement</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> imagemanagement;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">GET</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Path</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;/image/{id}/&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  public</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> ImageDto </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getImage</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">PathParam</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;id&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">long</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.imagemanagement.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">findImage</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(id);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>在这里，我们可以看到[业务组件] <code>imagemanagement</code>的 REST 服务。 方法<code>getImage</code>可以通过<code>@GET</code>URL 路径<code>imagemanagement/image/{id}</code>（参见<code>@Path</code>注释）下的 HTTP GET 访问， 其中<code>{id}</code>是所请求表的 ID，将从 URL 中提取并作为参数<code>id</code>提供给该方法<code>getImage</code>。 它将其结果 (<code>ImageDto</code>) 作为 JSON 返回（请参阅<code>@Produces</code>注解 - 您还可以扩展<code>RestService</code>为 JSON 定义这些注解的标记接口）。 如您所见，它委托给包含实际业务逻辑的逻辑组件<code>imagemanagement</code>，而服务本身仅通过 HTTP 公开此逻辑。 REST 服务实现是一个常规的 CDI bean，可以使用依赖注入。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>对于 JAX-RS，确保每个服务方法都使用正确的 HTTP 方法（<code>@GET</code>、<code>@POST</code> 等）进行注释以避免不必要的调试非常重要。因此，您应该注意不要忘记指定这些注释之一。</p></div><h3 id="服务接口" tabindex="-1">服务接口 <a class="header-anchor" href="#服务接口" aria-label="Permalink to &quot;服务接口&quot;">​</a></h3><p>如果您想为[service-client]重用 API，您还可以将 API 和实现分开：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Path</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;/imagemanagement/v1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Consumes</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(MediaType.APPLICATION_JSON)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Produces</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(MediaType.APPLICATION_JSON)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> ImagemanagementRestService</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">GET</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Path</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;/image/{id}/&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  ImageEto </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getImage</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">PathParam</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;id&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">long</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Named</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;ImagemanagementRestService&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> ImagemanagementRestServiceImpl</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> ImagemanagementRestService</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Override</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  public</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> ImageEto </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getImage</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">long</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.imagemanagement.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">findImage</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(id);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><h3 id="jax-rs-配置" tabindex="-1">JAX-RS 配置 <a class="header-anchor" href="#jax-rs-配置" aria-label="Permalink to &quot;JAX-RS 配置&quot;">​</a></h3><p>从 CXF 3.0.0 开始，可以启用 JAX-RS 根Package 的自动发现。</p><p>当 JAX-RS 服务器被实例化时，所有扫描的根Package和 provider beans（用<code>javax.ws.rs.Path</code>和<code>javax.ws.rs.ext.Provider</code>注释的 bean）都将被配置。</p><h3 id="rest-异常处理" tabindex="-1">REST 异常处理 <a class="header-anchor" href="#rest-异常处理" aria-label="Permalink to &quot;REST 异常处理&quot;">​</a></h3><p>对于异常，服务需要有一个异常门面(facade)来捕获所有异常， 这个门面（facade）通过编写适当的日志消息并将它们映射到具有相应 HTTP 状态代码的 HTTP 响应来处理它们。 为此，devon4j 提供了一个通用解决方案<code>RestServiceExceptionFacade</code>， 您可以在 Spring 应用程序中使用它。您需要遵循<a href="https://devonfw.com/website/pages/docs/asciidoc_devonfw-guide_devon4j.wiki_devon4j.asciidoc_guides.html#devonfw-guide_devon4j.wiki_guide-exceptions.asciidoc" target="_blank" rel="noreferrer">异常指南</a> 才能使其开箱即用，因为门面需要能够区分业务异常和技术异常。</p><p>要在 Quarkus 中实现通用异常门面，请遵循<a href="https://devonfw.com/website/pages/docs/devonfw-guide_devon4j.wiki_guide-rest.asciidoc.html#devonfw-guide_devon4j.wiki_quarkus_guide-exception-handling.asciidoc" target="_blank" rel="noreferrer">Quarkus 异常指南</a>。</p><p>现在您的服务可能会抛出异常，但门面会自动为您处理它们。</p><p>向客户端返回错误的一般格式如下：</p><div class="language-json5 vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json5</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">  &quot;message&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;A human-readable message describing the error&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">  &quot;code&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;A code identifying the concrete error&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">  &quot;uuid&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;An identifier (generally the correlation id) to help identify corresponding requests in logs&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><h3 id="分页详情" tabindex="-1">分页详情 <a class="header-anchor" href="#分页详情" aria-label="Permalink to &quot;分页详情&quot;">​</a></h3><p>我们建议使用[spring-data 存储库]来访问已经附带分页支持的数据库。 因此，在执行搜索时，您可以包含一个<a href="https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/domain/Pageable.html" target="_blank" rel="noreferrer">Pageable</a>对象。 这是一个 JSON 示例：</p><div class="language-json5 vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json5</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{ </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;pageSize&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">20</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;pageNumber&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;sort&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">: [] }</span></span></code></pre></div><p>通过增加<code>pageNumber</code>，客户端可以浏览和分页查询命中的数据。</p><p>最终，您将收到一个<a href="https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/domain/Page.html" target="_blank" rel="noreferrer">Page</a>。 它是您的搜索结果的容器，就像 <code>Collection</code> 一样，但还包含客户端的分页信息。这是一个 JSON 示例：</p><div class="language-json5 vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json5</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{ </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;totalElements&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">1022</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">  pageable</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">: { </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;pageSize&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">20</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;pageNumber&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> },</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">  content</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">: [ </span><span style="--shiki-light:#B31D28;--shiki-dark:#FF938A;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> ] }</span></span></code></pre></div><p>该<code>totalElements</code>属性包含命中数据总数。客户端可以使用它来计算页面总数并相应地呈现分页链接。 通过<code>pageable</code>属性，客户端从搜索请求中取回<code>Pageable</code>属性。当前页面实际命中的数据在<code>content</code>属性中作为数组返回。</p><h2 id="rest-测试" tabindex="-1">REST 测试 <a class="header-anchor" href="#rest-测试" aria-label="Permalink to &quot;REST 测试&quot;">​</a></h2><p>对于一般测试 REST 服务，请参阅<a href="https://devonfw.com/website/pages/docs/asciidoc_devonfw-guide_devon4j.wiki_devon4j.asciidoc_guides.html#devonfw-guide_devon4j.wiki_guide-testing.asciidoc" target="_blank" rel="noreferrer">测试指南</a>。</p><p>对于手动测试 REST 服务，有浏览器插件：</p><ul><li>Firefox：<a href="https://addons.mozilla.org/de/firefox/addon/rested/" target="_blank" rel="noreferrer">rested</a></li><li>Chrome：<a href="http://www.getpostman.com/" target="_blank" rel="noreferrer">postman</a>（<a href="https://chrome.google.com/webstore/detail/advanced-rest-client/hgmloofddffdnphfgcellkdfbfbjeloo" target="_blank" rel="noreferrer">advanced-rest-client</a>）</li></ul><h2 id="安全" tabindex="-1">安全 <a class="header-anchor" href="#安全" aria-label="Permalink to &quot;安全&quot;">​</a></h2><p>您的服务是应用程序的主要入口点。因此，安全考虑在这里很重要。</p><h3 id="csrf" tabindex="-1">CSRF <a class="header-anchor" href="#csrf" aria-label="Permalink to &quot;CSRF&quot;">​</a></h3><p>一个常见的安全威胁是 REST 服务的<a href="https://www.owasp.org/index.php/Top_10_2013-A8-Cross-Site_Request_Forgery_(CSRF)" target="_blank" rel="noreferrer">CSRF</a>。 因此，所有执行修改的 REST 操作（PUT、POST、DELETE 等 - 除了 GET 之外的所有操作）都必须保护免受 CSRF 攻击。 请参阅<a href="https://devonfw.com/website/pages/docs/asciidoc_devonfw-guide_devon4j.wiki_devon4j.asciidoc_guides.html#devonfw-guide_devon4j.wiki_guide-csrf.asciidoc" target="_blank" rel="noreferrer">CSRF</a>如何执行此操作。</p><h3 id="json-顶级数组" tabindex="-1">JSON 顶级数组 <a class="header-anchor" href="#json-顶级数组" aria-label="Permalink to &quot;JSON 顶级数组&quot;">​</a></h3><p>OWASP 早些时候建议不要在顶层返回 JSON 数组，以防止没有理由的攻击。 我们深入挖掘并发现了 <a href="https://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx/" target="_blank" rel="noreferrer">anatomy-of-a-subtle-json-vulnerability</a>。 总而言之，这种攻击已经存在很多年了，并且在任何最近的或相关的浏览器中都不起作用。 因此，可以在 JSON REST 服务中使用数组作为顶级结果（意味着您可以在 Java JAX-RS 服务中返回<code>List&lt;Foo&gt;</code>）。</p>`,50),h=[n];function l(p,d,r,k,o,g){return a(),i("div",null,h)}const y=s(t,[["render",l]]);export{A as __pageData,y as default};
