import{_ as a,a as t,af as r,o}from"./chunks/framework.C87LdZyP.js";const u=JSON.parse('{"title":"Devon4j: Log Monitoring","description":"","frontmatter":{"title":"Devon4j: Log Monitoring","date":"2022-06-23T00:00:00.000Z","tags":["devon4j"],"category":["架构"]},"headers":[],"relativePath":"posts/2022/06/2022-06-23-devon4j-log-monitoring.md","filePath":"posts/2022/06/2022-06-23-devon4j-log-monitoring.md","lastUpdated":1718173059000}'),l={name:"posts/2022/06/2022-06-23-devon4j-log-monitoring.md"};function i(n,e,s,p,d,g){return o(),t("div",null,e[0]||(e[0]=[r('<p>日志监控是监控的一个方面，严格关注日志记录。 随着 IT 环境趋向于拥有许多但小得多的应用程序，将日志文件写入磁盘并让操作员通过 SSH 读取这些文件的经典方法已完全过时。 如今，我们有多达数百甚至数千个应用程序，它们本身被集群到多个节点中。 因此，您应该在环境中建立一个集中的日志监控系统，让您的所有节点直接登录到该系统。这种方法具有以下好处：</p><ul><li>所有日志信息都在一个地方可用</li><li>跨所有日志文件的全文搜索</li><li>从特定日志模式自动触发警报的能力</li><li>能够对日志进行数据挖掘并在仪表板中进行可视化</li></ul><h2 id="日志监控选项" tabindex="-1">日志监控选项 <a class="header-anchor" href="#日志监控选项" aria-label="Permalink to &quot;日志监控选项&quot;">​</a></h2><p>这种日志监控系统的典型产品有：</p><ul><li><a href="https://www.elastic.co/de/what-is/elk-stack" target="_blank" rel="noreferrer">ELK-Stack</a></li><li><a href="https://www.graylog.org/" target="_blank" rel="noreferrer">Graylog</a></li><li><a href="https://www.splunk.com/" target="_blank" rel="noreferrer">Splunk</a></li></ul><p>在 devonfw 中，我们对任何这些产品都没有偏见。因此，请随时根据项目的要求做出选择。</p><p>对于 Quarkus 应用程序，您可以通过阅读有关<a href="https://quarkus.io/guides/centralized-log-management" target="_blank" rel="noreferrer">集中式日志管理</a>的指南来深入了解该主题。</p><h2 id="用于日志监控的-api" tabindex="-1">用于日志监控的 API <a class="header-anchor" href="#用于日志监控的-api" aria-label="Permalink to &quot;用于日志监控的 API&quot;">​</a></h2><p>为您的应用程序记录到日志监控系统的「API」非常简单：</p><ul><li>将您的日志写入标准输出。</li><li>使用 JSON 作为日志记录格式。</li></ul><p>然后容器基础设施可以自动从标准输出收集您的日志，并将这些日志直接输入到日志监控系统中。 您的应用程序不需要了解有关您的日志监控系统的任何信息，并且日志记录变得最简单。 此外，如果您不再编写日志文件，您可能不需要编写任何其他文件，因此甚至可能不需要对容器文件系统的写入权限。 在这种情况下，可能在您的应用程序中发现漏洞的攻击者将具有更少的攻击面，以防他无法写入任何文件。</p>',11)]))}const h=a(l,[["render",i]]);export{u as __pageData,h as default};
