import{_ as e,a as r,af as t,o}from"./chunks/framework.C87LdZyP.js";const u=JSON.parse('{"title":"DevOps: CI/CD Pipeline","description":"","frontmatter":{"title":"DevOps: CI/CD Pipeline","date":"2022-05-28T00:00:00.000Z","tags":["devsecops","devops"],"category":["运维"]},"headers":[],"relativePath":"posts/2022/05/2022-05-28-cicd-pipeline.md","filePath":"posts/2022/05/2022-05-28-cicd-pipeline.md","lastUpdated":1718173059000}'),p={name:"posts/2022/05/2022-05-28-cicd-pipeline.md"};function i(s,a,n,l,h,d){return o(),r("div",null,a[0]||(a[0]=[t('<h2 id="什么是-devops-中的持续集成" tabindex="-1">什么是 DevOps 中的持续集成？ <a class="header-anchor" href="#什么是-devops-中的持续集成" aria-label="Permalink to &quot;什么是 DevOps 中的持续集成？&quot;">​</a></h2><p>在 DevOps 中，持续集成 (CI) 涉及在团队中的开发人员每次将代码提交到版本控制时自动化构建和部署代码的过程。开发人员通过将所有更改合并到共享存储库来共享代码，包括最小的更改。每次提交代码时，它都会启动一个自动化流水线，该流水线检索最新代码并继续构建、测试和验证主分支或主干分支。</p><p>CI 被设想和实施为解决特定问题的最佳实践。当编码员孤立地工作并且不得不在几天或几周结束时将更改与团队的代码库集成时，他们发现这会导致频繁的合并冲突、令人沮丧的错误、不兼容的编码策略和重复。</p><p>通过一致的代码提交到共享分支，这些问题显着减少。代码经过测试以尽早消除错误，并尽早发现与较大代码体的不一致之处。</p><h2 id="devops-中持续集成的好处" tabindex="-1">DevOps 中持续集成的好处 <a class="header-anchor" href="#devops-中持续集成的好处" aria-label="Permalink to &quot;DevOps 中持续集成的好处&quot;">​</a></h2><h3 id="更小更容易的代码更改" tabindex="-1">更小更容易的代码更改 <a class="header-anchor" href="#更小更容易的代码更改" aria-label="Permalink to &quot;更小更容易的代码更改&quot;">​</a></h3><p>‍随着每次代码更改都立即推送到版本控制，CI/CD 流水线必须一次处理较小的代码更改和集成。显然，与可能包含多个难以检测的错误的大型脚本相比，此类更改更易于处理、测试和调试。这个想法是将功能和新开发分解成字节大小的片段，这些片段可以快速写入。<strong>‍</strong></p><h3 id="更容易调试" tabindex="-1">更容易调试 <a class="header-anchor" href="#更容易调试" aria-label="Permalink to &quot;更容易调试&quot;">​</a></h3><p>基于 CI 的流水线有助于故障隔离，也就是规划系统来让错误导致有限负面后果的实践。这可以保护系统免受重大损坏，并使维护更容易。</p><p>持续集成有助于故障隔离，因为较小的代码更改可以更容易地发现错误，并在它们对整个生态系统产生不利影响之前解决它们 - 这在 CI 到位时不容易实现。</p><h3 id="更快的产品发布" tabindex="-1">更快的产品发布 <a class="header-anchor" href="#更快的产品发布" aria-label="Permalink to &quot;更快的产品发布&quot;">​</a></h3><p>‍由 CI 驱动的流水线是一个持续移动的系统，在该系统中可以更快地检测和调试故障。这总是会导致更快、更频繁的发布，从而转化为更快乐的客户和优于竞争对手的积极优势。<strong>‍</strong></p><h3 id="更轻的积压" tabindex="-1">更轻的积压 <a class="header-anchor" href="#更轻的积压" aria-label="Permalink to &quot;更轻的积压&quot;">​</a></h3><p>‍如上所述，CI 可以在代码更改和集成的早期阶段更快地识别和调试错误。由于在预生产中快速修复了小缺陷，开发人员需要修复的可避免的非关键错误的积压较少。他们可以花时间专注于更大的问题，编写更好的代码并不断更新系统以提高效率。 不用说，更少的错误会带来更低的成本、更容易的维护、更好的代码质量和更高的投资回报率。<strong>‍</strong></p><h3 id="提高透明度和问责制" tabindex="-1">提高透明度和问责制 <a class="header-anchor" href="#提高透明度和问责制" aria-label="Permalink to &quot;提高透明度和问责制&quot;">​</a></h3><p>‍频繁的代码提交会导致来自自动化系统和团队的即时和频繁的反馈。这使问题对团队可见和透明，让每个人都在同一页面上。</p><p>CI 阶段的反馈对构建问题、合并冲突、更大的架构障碍等有直接影响。因此，它不仅让开发人员了解他们和他们的团队成员在做什么，而且还让他们了解系统的健康状况。正在营业 。‍</p><p>当然，单靠 CI 无法实现快速创建软件所需的无缝可操作性，并且缺陷最少。它本身也不能在软件工程团队或组织内建立 DevOps 原则。为此，流水线需要 CD - 持续交付/持续部署</p><h2 id="持续交付" tabindex="-1">持续交付 <a class="header-anchor" href="#持续交付" aria-label="Permalink to &quot;持续交付&quot;">​</a></h2><p>在 DevOps 中，持续交付 (CD) 是一种实践，其中所有代码更改都会自动测试并准备好发布。一旦持续集成负责代码构建和集成，交付就会将更改推送到测试环境，然后为生产做好准备。从本质上讲，有了 CD，团队将始终拥有经过测试并获准公开发布的可部署产品。</p><p>持续交付使代码超越了在 CI 阶段运行的简单单元测试。它允许软件通过多个评估层运行，以便从各个方面验证功能。这可以包括集成测试、UI 测试、负载测试、端到端测试、API 测试、回归测试、安全测试等。它允许开发人员更全面地验证产品并在产品到达客户手中之前排除问题。</p><h2 id="持续部署" tabindex="-1">持续部署 <a class="header-anchor" href="#持续部署" aria-label="Permalink to &quot;持续部署&quot;">​</a></h2><p>CD 有时也可以指持续部署——这是持续交付的下一个阶段。一旦代码准备好发布，持续部署就是将其自动推送到生产环境的过程。</p><p>在这种情况下，自动化取决于流水线中的一系列先入为主的和预先建立的测试。代码更改通过这些测试，如果一切顺利，流水线将触发它们直接发布到生产环境。无需人为干预或批准。</p><h2 id="持续交付与持续部署" tabindex="-1">持续交付与持续部署 <a class="header-anchor" href="#持续交付与持续部署" aria-label="Permalink to &quot;持续交付与持续部署&quot;">​</a></h2><p><strong>持续部署</strong>本质上为<strong>持续交付</strong>增加了一个额外的步骤。前者将每个代码自动推送到生产环境，无需人工主管的明确批准。流水线从存储库中获取代码，拉取适当的配置，即时构建虚拟机、容器等，然后部署代码，一举完成。</p><p>在<strong>持续交付</strong>的情况下，代码被构建、集成和测试以准备好生产。但是，它需要开发人员、产品经理或团队负责人的批准才能真正发布到生产环境中。</p><p><strong>使用哪种连续模型？</strong> 这个问题，取决于组织的目标、员工的技能水平以及他们可用于获取正确 CI/CD 工具的资源。<a href="https://www-opsera-io.translate.goog/blog/a-journey-towards-devops-at-scale?_x_tr_sl=en&amp;_x_tr_tl=zh-CN&amp;_x_tr_hl=en&amp;_x_tr_pto=wapp" target="_blank" rel="noreferrer">在DevOps</a>中实施 CI/CD是为了拥有适当的工具和检查来管理配置并在发生错误或故障时回滚。</p><h2 id="什么是-devops-中的-ci-cd-流水线" tabindex="-1">什么是 DevOps 中的 CI/CD 流水线？ <a class="header-anchor" href="#什么是-devops-中的-ci-cd-流水线" aria-label="Permalink to &quot;什么是 DevOps 中的 CI/CD 流水线？&quot;">​</a></h2><p>CI/CD 流水线包含许多串行进程，这些进程被执行以交付新版本的软件（网站/应用程序）。CI/CD 旨在通过利用 DevOps 原则并在每一步利用自动化来加速和改进软件交付。</p><p>一致的自动化和监控被整合到 CI/CD 流水线中，以便在消耗更少资源（时间、金钱、精力）的同时提高开发效率。流水线中的每一步都是自动化的——从代码被推送到存储库的那一刻起，它就通过自动化机制进行构建、集成、测试、部署和监控。</p><p>不用说，CI/CD 流水线的商业利益是多方面的。它们加速了开发并减少了出错的可能性。从本质上讲，它使企业能够以最少的人工参与每天多次发布软件。</p><h2 id="ci-cd-流水线的最佳实践" tabindex="-1">CI/CD 流水线的最佳实践 <a class="header-anchor" href="#ci-cd-流水线的最佳实践" aria-label="Permalink to &quot;CI/CD 流水线的最佳实践&quot;">​</a></h2><h3 id="尽早并经常提交" tabindex="-1">尽早并经常提交 <a class="header-anchor" href="#尽早并经常提交" aria-label="Permalink to &quot;尽早并经常提交&quot;">​</a></h3><p>每次开发人员提交代码时，他们都会启动一系列自动化测试，以提供反馈并通知团队发生了更改。定期代码提交可确保整个团队保持在同一页面上，从而实现更好的协作。它还降低了在集成较大的代码更改时通常出现的令人沮丧的合并冲突的可能性。</p><p>通过与整个团队共享所有更改（通过将代码推送到主分支），每个人都可以保持更新并可以修改自己的工作以匹配最佳和最新版本的软件。每天至少提交一次代码是明智之举，尽管大多数大公司的承诺要多得多。</p><h3 id="坚持一个构建" tabindex="-1">坚持一个构建 <a class="header-anchor" href="#坚持一个构建" aria-label="Permalink to &quot;坚持一个构建&quot;">​</a></h3><p>不要为流水线的每个阶段创建新的建筑物。在不同的环境中这样做可能会在软件中引入不一致，这意味着您不能依赖以前的测试结果。相反，一个构建工件应该通过每个阶段并最终发布到生产中。</p><h3 id="保持环境原始" tabindex="-1">保持环境原始 <a class="header-anchor" href="#保持环境原始" aria-label="Permalink to &quot;保持环境原始&quot;">​</a></h3><p>要获得准确的测试结果，请在部署之间清理预生产环境。如果环境运行时间很长，团队必须处理难以跟踪的多个配置更改和更新。</p><p>随着将它们恢复到原始状态，在一种环境中通过的测试可能在另一种环境中失败。为防止这种情况，请使用容器来托管环境并运行测试。这使得部署后更容易拆除环境。</p><h3 id="监控和测量" tabindex="-1">监控和测量 <a class="header-anchor" href="#监控和测量" aria-label="Permalink to &quot;监控和测量&quot;">​</a></h3><p>‍大部分团队会为生产环境建立监控机制，以便快速发现任何错误或异常。同样，CI/CD 流水线必须配备用于监控和评估的指标。通过分析这些指标，开发人员和团队经理可以缩小潜在错误的范围并在它们转移之前进行处理。他们还可以检测模块以进行改进。</p><h3 id="简化测试" tabindex="-1">简化测试 <a class="header-anchor" href="#简化测试" aria-label="Permalink to &quot;简化测试&quot;">​</a></h3><p>不要期望从一开始就自动化每个测试。从运行速度最快的测试（单元测试）开始，尽早运行它们以获得初始反馈层。一旦这些完成并且您对构建稳定性有了一些了解，就可以进行更长更复杂的测试。</p><p>手动测试需要更长的时间，并且取决于是否有合适的人员。因此，请尽量减少它们（您永远无法完全消除它们）并在完成自动化测试后将它们保留下来。相反，确保测试人员专注于创建完成工作的成熟、全面的自动化测试脚本。</p><h2 id="ci-cd-流水线阶段-细分" tabindex="-1">CI/CD 流水线阶段：细分 <a class="header-anchor" href="#ci-cd-流水线阶段-细分" aria-label="Permalink to &quot;CI/CD 流水线阶段：细分&quot;">​</a></h2><p>要定义 CI/CD 流水线，请查看基本步骤：  <strong>开发 → 构建 → 测试 → 部署。</strong></p><p>随着我们扩展流水线，我们还有监控 → 反馈 → 运营。</p><h3 id="开发" tabindex="-1">开发 <a class="header-anchor" href="#开发" aria-label="Permalink to &quot;开发&quot;">​</a></h3><p>在这里，我们正在编写代码，这意味着我们需要一个存储库来存储和签出代码。</p><h3 id="构建" tabindex="-1">构建 <a class="header-anchor" href="#构建" aria-label="Permalink to &quot;构建&quot;">​</a></h3><p>当代码签入到存储库时，该代码将集成到主分支中。这是需要版本控制的地方。在较旧的瀑布式工作流程中，集成/构建只会在完成主要功能集或大量代码更改后发生。在更敏捷、更连续的模型中工作时，代码将被集成到每天的功能时间中。代码被分解成更小的工作函数，允许迭代改进和快速集成结果。</p><h3 id="测试-质量‍" tabindex="-1">测试/质量‍ <a class="header-anchor" href="#测试-质量‍" aria-label="Permalink to &quot;测试/质量‍&quot;">​</a></h3><p>构建代码后，必须对生成的应用程序进行错误、功能故障和质量测试。这些测试可以而且应该使用任意数量的专用工具实现自动化。通过在每次构建时进行测试，可以快速收到反馈并快速实施更正。</p><h3 id="安全扫描‍" tabindex="-1">安全扫描‍ <a class="header-anchor" href="#安全扫描‍" aria-label="Permalink to &quot;安全扫描‍&quot;">​</a></h3><p>作为我们从附加审计和事后审计过渡的一部分，安全扫描是持续循环的关键部分。安全扫描可以自动检测漏洞和不安全的实施，然后再被释放并被不良行为者利用。将这一步骤包含在流水线的测试部分中至关重要——正如他们所说，“一盎司的预防胜过一磅的治疗。”</p><h3 id="部署" tabindex="-1">部署 <a class="header-anchor" href="#部署" aria-label="Permalink to &quot;部署&quot;">​</a></h3><p>代码已构建，测试提供了绿灯，是时候将我们的更改推送到环境中，无论是预生产还是生产。通过持续部署，定期自动推送到非生产环境可以为代码在发布到面向客户的环境时的执行情况提供清晰的反馈和指标。在预生产中通过适当的测试后，可以使用任何满足您要求的方法或模型将代码自动发布到生产中。</p><h2 id="devops-中的-ci-cd-工具" tabindex="-1">Devops 中的 CI/CD 工具 <a class="header-anchor" href="#devops-中的-ci-cd-工具" aria-label="Permalink to &quot;Devops 中的 CI/CD 工具&quot;">​</a></h2><p>在基于 DevOps 的团队中，有大量用于促进 CI/CD 流程的工具。一些最受欢迎的包括：</p><p><strong>配置管理</strong> - Ansible、Puppet、Chef</p><p><strong>代码管理</strong> - GitHub、GitLab、BitBucket</p><p><strong>构建</strong> - Jenkins、Bamboo、TeamCity</p><p><strong>测试</strong> - Selenium、JUnit、SonarQube</p><p><strong>部署</strong> - Argo、Spinnaker、Octopus 部署</p><p><em>有关 CI/CD 工具的详细分类，请在此处阅读：</em> <a href="https://www.opsera.io/blog/best-devops-tools" target="_blank" rel="noreferrer"><em>25 个 CI/CD 工具</em></a></p><hr><ul><li><a href="https://www.opsera.io/blog/all-you-need-to-know-about-ci-cd-pipeline" target="_blank" rel="noreferrer">https://www.opsera.io/blog/all-you-need-to-know-about-ci-cd-pipeline</a></li></ul>',69)]))}const b=e(p,[["render",i]]);export{u as __pageData,b as default};
