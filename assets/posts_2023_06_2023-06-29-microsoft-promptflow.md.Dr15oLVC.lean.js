import{_ as i,a,af as t,o as l}from"./chunks/framework.C87LdZyP.js";const p="/assets/2280235470701875.DfeRW_TM.png",n="/assets/2280959040118458.D37B8IK0.png",e="/assets/2282633374391291.eStKRW8v.png",h="/assets/2282717425825125.C1iQ-sOA.png",o="/assets/2283026321284541.ClAlIXFt.png",k="/assets/2283326531627708.CG_7ORqq.png",r="/assets/2283729825215333.Bt6Y1l8z.png",d="/assets/2284260797489541.BtTqNpR5.png",c="/assets/2284375814671166.BIEA3Ork.png",g="/assets/2284709302120875.C-Yi2a8H.png",m="/assets/2285321442286291.qkkO1bS_.png",y="/assets/2286050663888208.Bzk8gZzS.png",u="/assets/2285748080211333.CFUQRlJK.png",F="/assets/116749308419416.D0cNoWvW.png",D="/assets/116757693813125.DLBYLKBs.png",C="/assets/116768006631166.Br_xP6QZ.png",A="/assets/116794210554125.D8AInMTO.png",b="/assets/2282025076380000.BFhXCMGp.png",f="/assets/116812514383083.CSG42BHv.png",L=JSON.parse('{"title":"构建高质量的 LLM 应用程序 - 从原型设计、测试到生产部署和监控","description":"","frontmatter":{"title":"构建高质量的 LLM 应用程序 - 从原型设计、测试到生产部署和监控","date":"2023-06-29T00:00:00.000Z","tags":["ai","ml"],"category":["AI"]},"headers":[],"relativePath":"posts/2023/06/2023-06-29-microsoft-promptflow.md","filePath":"posts/2023/06/2023-06-29-microsoft-promptflow.md","lastUpdated":1718173059000}'),_={name:"posts/2023/06/2023-06-29-microsoft-promptflow.md"};function B(v,s,w,x,q,P){return l(),a("div",null,s[0]||(s[0]=[t(`<blockquote><p>今天介绍微软开源 Prompt 工程开发工具 <strong>PromptFlow</strong>，该工具旨在简化基于 LLM 的人工智能应用程序的端到端开发周期： 从构思、原型设计、测试、评估到生产部署和监控。它使 Prompt 工程变得更加容易，并使您能够构建具有<strong>生产质量</strong>的 LLM 应用程序。</p></blockquote><p>使用该工具可以：</p><ul><li>创建将 LLM、提示、Python 代码和其他工具链接在一起的可执行工作流程。</li><li>轻松调试和迭代您的流程，尤其是与 LLM 的交互。</li><li>使用更大的数据集评估流程的质量和性能。</li><li>将测试和评估集成到您的 CI/CD 系统中，以确保流程的质量。</li><li>将您的流程部署到您选择的服务平台或轻松集成到应用程序的代码库中。</li></ul><p>GitHub 地址： <a href="https://github.com/microsoft/promptflow" target="_blank" rel="noreferrer">https://github.com/microsoft/promptflow</a></p><h2 id="快速入门" tabindex="-1">快速入门 <a class="header-anchor" href="#快速入门" aria-label="Permalink to &quot;快速入门&quot;">​</a></h2><p>下面演示如何：</p><ul><li>设置 Python 环境以运行 Prompt Flow</li><li>克隆和运行示例流并了解什么是 Prompt Flow</li><li>使用可视化编辑器或 yaml 编辑流程</li><li>使用 CLI、SDK 和 VS Code 扩展来测试流</li></ul><h3 id="设置开发环境" tabindex="-1">设置开发环境 <a class="header-anchor" href="#设置开发环境" aria-label="Permalink to &quot;设置开发环境&quot;">​</a></h3><p>使用 Python 3.9 以上的版本，还是使用我们最喜欢的 conda 来创建一个新环境：</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">conda</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> create</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> --name</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> pf</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> python=</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">3.9</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">conda</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> activate</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> pf</span></span></code></pre></div><p>安装<strong>promptflow</strong> 和 <strong>promptflow-tools</strong>：</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">pip</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> install</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> promptflow</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> promptflow-tools</span></span></code></pre></div><p>使用 <code>pf -v</code> 查看安装版本信息：</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> pf -v</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">0.1.0b4</span></span></code></pre></div><h3 id="什么是流" tabindex="-1">什么是流 <a class="header-anchor" href="#什么是流" aria-label="Permalink to &quot;什么是流&quot;">​</a></h3><p>这里的流是由函数组成的有向无环图（DAG），用 YAML 文件描述， 然后通过 Prompt Flow 执行器执行。</p><p>看看下面的例子就能明白：</p><p><img src="`+p+`" alt=""></p><ul><li>左边是 YAML 表示</li><li>右边是可视化展示，YAML 的每个节点都和右边的节点对应</li></ul><h3 id="工程化" tabindex="-1">工程化 <a class="header-anchor" href="#工程化" aria-label="Permalink to &quot;工程化&quot;">​</a></h3><p>现阶段大多数的工具、框架（比如 LangChain）都没有提供工程化的相关支持，比如目录约定、构建发布等等。 而 Prompt Flow 作为一个可以构建生产质量 LLM 应用的工具，提供了很好的工程目录供我们参考和使用。</p><p>我们可以直接去 Github 上下载查看样例：</p><p><a href="https://github.com/microsoft/promptflow/tree/main/examples/flows" target="_blank" rel="noreferrer">https://github.com/microsoft/promptflow/tree/main/examples/flows</a></p><p>克隆项目，然后进入到样例目录：</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> clone</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> https://github.com/microsoft/promptflow.git</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">cd</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> promptflow-main/examples/flows/standard/web-classification</span></span></code></pre></div><p>比如官方推荐的模板项目：经典的 Web 分类任务。</p><p>有如下文件：</p><ul><li><code>flow.dag.yaml</code>：用于创作目的的具有输入/输出、节点、工具和变体的流定义；</li><li><code>.promptflow/flow.tools.json</code>：它包含 中引用的所有包工具元；</li><li>源代码和模板（<code>.py</code>、<code>.jinja2</code>）：用户管理的，工具引用的代码脚本；</li><li><code>requirements.txt</code>：此流程的 Python 包依赖项；</li><li><code>data.jsonl</code>： json 数据文件；</li><li><code>run.yaml</code>：运行脚本；</li><li><code>run_evaluation.yml</code>：评估脚本。</li></ul><p><img src="`+n+'" alt=""></p><h2 id="创建连接" tabindex="-1">创建连接 <a class="header-anchor" href="#创建连接" aria-label="Permalink to &quot;创建连接&quot;">​</a></h2><p>连接（connection）可以让我们安全地存储和管理与 LLM 等外部工具（例如OpenAI、各种网络服务）交互所需的密钥或其他敏感凭据。</p><p>新建 <code>connection.yaml</code> 文件，填写你的 openai key： <img src="'+e+`" alt=""></p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">$schema</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">https://azuremlschemas.azureedge.net/promptflow/latest/AzureOpenAIConnection.schema.json</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">open_ai_connection</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">type</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">open_ai</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">api_key</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">sk-***</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">organization</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;&quot;</span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;"> # optional</span></span></code></pre></div><p>执行命令 <code>pf connection create -f connection.yaml</code> 创建 连接：</p><p><img src="`+h+'" alt=""></p><h2 id="测试-flow" tabindex="-1">测试 Flow <a class="header-anchor" href="#测试-flow" aria-label="Permalink to &quot;测试 Flow&quot;">​</a></h2><p>刚才我们说了，这个样例目录任务是Web 分类流，它将 URL 分类为几个预定义的类(分类是一项传统的机器学习任务)。</p><p>测试之前，先更改你想测试的网址作为默认输入，我们使用网速测试器 baidu 网站：</p><p><img src="'+o+'" alt=""></p><p>然后使用命令行运行：</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">pf</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> flow</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> test</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> --flow</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> .</span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">  # 最后的点表示当前目录</span></span></code></pre></div><p>可以看到控制台输出判断该网站是应用（APP）：</p><p><img src="'+k+'" alt=""></p><p>然后我们再测试下清华大学的网站：</p><ul><li><a href="https://www.tsinghua.edu.cn/xxgk.htm" target="_blank" rel="noreferrer">https://www.tsinghua.edu.cn/xxgk.htm</a></li></ul><p>可以看到得到的分类是大学（Academic）：</p><p><img src="'+r+'" alt=""></p><h2 id="promptflow-原理" tabindex="-1">PromptFlow 原理 <a class="header-anchor" href="#promptflow-原理" aria-label="Permalink to &quot;PromptFlow 原理&quot;">​</a></h2><p>我们刚刚运行完，也看到了结果，但是大家肯定都和我一样是一脸懵逼，有很多疑问：</p><ul><li>刚才是啥？</li><li>做了什么？</li><li>为什么有了结果？</li><li>执行的逻辑是什么？</li><li>。。。</li></ul><p>下面我们一起看看其背后的逻辑。</p><h3 id="流程描述文件结构" tabindex="-1">流程描述文件结构 <a class="header-anchor" href="#流程描述文件结构" aria-label="Permalink to &quot;流程描述文件结构&quot;">​</a></h3><p>首先查看 <code>flow.dag.yaml</code> 文件，主要有以下节点：</p><ul><li>$schema</li><li>inputs</li><li>outputs</li><li>nodes</li><li>node_variants</li><li>environment</li></ul><p><img src="'+d+'" alt=""></p><p>我们平时关心的就是输入、输出和节点三部分，节点部分会有多个节点相关连接，可视化如下：</p><p><img src="'+c+`" alt=""></p><h4 id="输入" tabindex="-1">输入 <a class="header-anchor" href="#输入" aria-label="Permalink to &quot;输入&quot;">​</a></h4><p>输入我们定义了一个叫 <code>url</code> 的参数，他是字符串类型，并且指定了默认值。</p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">inputs</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">  url</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">    type</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">string</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">    default</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">https://www.tsinghua.edu.cn/xxgk.htm</span></span></code></pre></div><h4 id="输出" tabindex="-1">输出 <a class="header-anchor" href="#输出" aria-label="Permalink to &quot;输出&quot;">​</a></h4><p>输出定了两个参数 <code>category</code> 和 <code>evidence</code>，他们都是 <code>convert_to_dict</code> 方法的 output，所有的输出参数会以对象的方式方式返回（比如 JSON 或者 Dict）， 也就是刚才我们执行流最后的输出：</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">outputs:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">  category:</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">    type</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> string</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">    reference:</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> \${convert_to_dict.output.category}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">  evidence:</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">    type</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> string</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">    reference:</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> \${convert_to_dict.output.evidence}</span></span></code></pre></div><h4 id="节点" tabindex="-1">节点 <a class="header-anchor" href="#节点" aria-label="Permalink to &quot;节点&quot;">​</a></h4><p>节点就是具体处理流的步骤，以 DAG 的形式组织，这个流里面一共定义了五个节点：</p><p><img src="`+g+`" alt=""></p><h4 id="读取网页" tabindex="-1">读取网页 <a class="header-anchor" href="#读取网页" aria-label="Permalink to &quot;读取网页&quot;">​</a></h4><p>我们看下第一个节点，这是一个<code>python</code> 类型的节点，调用 <code>fetch_text_content_from_url.py</code> 文件， 使用 <code>\${inputs.url}</code> url 参数作为 python 代码的输入。</p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">- </span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">fetch_text_content_from_url</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">  type</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">python</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">  source</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">    type</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">code</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">    path</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">fetch_text_content_from_url.py</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">  inputs</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">    url</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">\${inputs.url}</span></span></code></pre></div><p>打开这个文件，可以看到使用 <code>@tool</code> 注解定义了方法，并接收了刚才声明的 url 参数，请求网页并，返回网页的前面 2000 个字符。</p><p>这个节点返回的数据可以被后来的节点使用。</p><h4 id="llm-判断" tabindex="-1">LLM 判断 <a class="header-anchor" href="#llm-判断" aria-label="Permalink to &quot;LLM 判断&quot;">​</a></h4><p>我们下面直接看第四个节点：节点的类型是 <strong>llm</strong>，使用 <code>source</code> 指定 Prompt 模板文件，以及输入参数，也就是模板文件的变量。</p><p>参数直接使用 <strong>任务名.output</strong> 来使用之前任意任务的输出结果，比如 <code>\${summarize_text_content.output}</code> 和 <code>\${prepare_examples.output}</code>。</p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">- </span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">classify_with_llm</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">  type</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">llm</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">  source</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">    type</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">code</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">    path</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">classify_with_llm.jinja2</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">  inputs</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    # This is to easily switch between openai and azure openai.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    # deployment_name is required by azure openai, model is required by openai.</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">    deployment_name</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">gpt-35-turbo</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">    model</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">gpt-3.5-turbo</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">    max_tokens</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">128</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">    temperature</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">0.2</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">    url</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">\${inputs.url}</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">    text_content</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">\${summarize_text_content.output}</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">    examples</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">\${prepare_examples.output}</span></span></code></pre></div><p>我们再看一下 Prompt 模板文件：</p><p><img src="`+m+'" alt=""></p><p>模板语法看不懂的话可以忽略，是不是和我们平时的 OpenAI Prompt 编程一样！</p><p>这里明确了分类的判断逻辑，你的分类可以是哪些以及证明可以是哪些：</p><p><img src="'+y+`" alt=""></p><p>最后还明确了返回数据的格式，就像我们之前《万物皆可 LLM》系列文章一样。</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">OUTPUT:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">&quot;category&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &quot;{{ex.category}}&quot;,</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &quot;evidence&quot;:</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &quot;{{ex.evidence}}&quot;}</span></span></code></pre></div><p>其他的节点类似，我们不挨个看了。</p><h2 id="回顾流程" tabindex="-1">回顾流程 <a class="header-anchor" href="#回顾流程" aria-label="Permalink to &quot;回顾流程&quot;">​</a></h2><p>在回头看可视化的流程就很清晰了：</p><p><img src="`+u+'" alt=""></p><ul><li>首先定义输入的参数</li><li>执行 python 节点：获取网页内容</li><li>执行 llm 节点：对网页内容进行摘要</li><li>同时使用 Python 节点：准备样例数据（少样本学习）</li><li>执行 llm 节点：把摘要和样例的结果给 llm 判断，输出指定格式</li><li>执行 python 节点：把 llm 判断结果格式化输出</li></ul><p>是不是很清晰，也很简单，我们不需要进行复杂的逻辑组织，只需要专注每个节点的逻辑，以及输入输出， Prompt Flow 会自动进行 DAG 图的组织。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>今天我们从零开始了解微软这个开源工具如何将 LLM 开发进行工程化的一个实现。</p><p>它还有很多其他的能力，比如 可视化的编辑、SDK 的编程、部署、发布、调试、监控等一些生产级别的特性，我们以后慢慢聊。</p><p><a href="https://microsoft.github.io/promptflow/" target="_blank" rel="noreferrer">https://microsoft.github.io/promptflow/</a></p><h2 id="vscode" tabindex="-1">VsCode <a class="header-anchor" href="#vscode" aria-label="Permalink to &quot;VsCode&quot;">​</a></h2><p>安装 Python 插件：</p><p><img src="'+F+'" alt=""></p><p>安装 Prompt Flow 插件：</p><p><img src="'+D+'" alt=""></p><p>选择 Python 运行时：</p><p><img src="'+C+'" alt=""></p><p>如果之前未安装可以点击执行依赖安装等命令：</p><p><img src="'+A+'" alt=""></p><p>打开 <code>flow.dag.yaml</code> 文件，并打开可视化视图：</p><p><img src="'+b+'" alt=""></p><p>可以看到可视化编辑和开发工具：</p><p><img src="'+f+'" alt=""></p><p>点击选择对应的解释器</p><hr><div style="text-align:center;color:#00000099;font-size:14px;">END</div>',108)]))}const M=i(_,[["render",B]]);export{L as __pageData,M as default};
