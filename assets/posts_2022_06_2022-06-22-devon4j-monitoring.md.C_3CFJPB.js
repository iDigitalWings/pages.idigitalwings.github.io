import{_ as e,a as r,o as t,aj as o}from"./chunks/framework.Ba_Ek9Jm.js";const m=JSON.parse('{"title":"Devon4j: Monitoring","description":"","frontmatter":{"title":"Devon4j: Monitoring","date":"2022-06-22T00:00:00.000Z","tags":["devon4j"],"category":["架构"]},"headers":[],"relativePath":"posts/2022/06/2022-06-22-devon4j-monitoring.md","filePath":"posts/2022/06/2022-06-22-devon4j-monitoring.md","lastUpdated":1718173059000}'),a={name:"posts/2022/06/2022-06-22-devon4j-monitoring.md"},n=o('<p>对于监控复杂的应用程序环境，准确了解哪些应用程序已启动并运行，哪些未运行以及原因至关重要。 在 devonfw 中，我们只关注开发生产就绪应用程序时最重要的主题。 在高级视图中，我们强烈建议将要监视的应用程序与其<code>monitoring system</code>本身分开。 因此，您的应用程序应专注于为监控提供特定于应用程序的数据。 聚合、可视化、搜索、警报等方面应在您的应用程序之外由监控系统产品解决。 有许多产品提供这样的监控系统，如<a href="https://checkmk.com" target="_blank" rel="noreferrer">checkmk</a>、 <a href="https://icinga.com/" target="_blank" rel="noreferrer">icinga</a>、 <a href="https://skywalking.apache.org/" target="_blank" rel="noreferrer">SkyWalking</a>等。 请注意，此类产品的列表非常庞大，devonfw 没有偏见或为您做出选择。相反，请搜索并找到最适合您的要求和基础架构的产品。</p><h2 id="监控类型" tabindex="-1">监控类型 <a class="header-anchor" href="#监控类型" aria-label="Permalink to &quot;监控类型&quot;">​</a></h2><p>由于监控涵盖了许多不同的方面，我们将以下类型的监控和数据分开：</p><ul><li><strong>日志监控</strong> 是关于收集和监控 IT 环境中所有应用程序和容器的日志。它适用于事件，例如带有 URL 的 HTTP 请求、结果状态代码和持续时间（以毫秒为单位）。您的监控可能无法实时对此类数据做出反应。相反，它可能需要一秒或几秒的延迟。</li><li><strong>基础设施监控</strong> 是关于通过 CPU、内存、磁盘空间等措施来监控（硬件）基础设施。这是一项纯粹的运维任务，您的应用程序应该与此无关。换句话说，如果您的应用程序试图监控这些方面是一种浪费，因为现有产品可以做得更好，而您的应用程序只能看到虚拟机而无法看到物理基础设施。</li><li><strong>运行状况检查</strong> 是关于提供有关应用当前运行状况的内部数据。通常，您为传感器提供每个组件的健康状态或与相邻服务（数据库连接等）的接口。</li><li><strong>应用程序性能监控</strong> 是关于测量性能和跟踪性能问题。</li></ul><h2 id="健康检查" tabindex="-1">健康检查 <a class="header-anchor" href="#健康检查" aria-label="Permalink to &quot;健康检查&quot;">​</a></h2><p>健康检查的想法是提供有关应用程序当前健康状态的监控数据。这允许将此特定数据集成到用于您的 IT 环境的监控系统中。为了保持监控简单且易于集成，请考虑使用以下最佳实践：</p><ul><li>通过 RMI使用简单且已建立的协议，例如 <strong>REST</strong> 而不是 <strong>JMX</strong> 。</li><li>考虑使用最新的标准，例如<a href="https://github.com/eclipse/microprofile-health" target="_blank" rel="noreferrer">microprofile-health</a>。</li><li>考虑放弃对监控接口的访问控制，并为了安全起见，防止在您的基础设施（负载均衡器或网关）中对其进行外部访问。监控仅供内部 IT 环境中使用。外部和最终用户访问您的应用程序以从负载均衡器决定的随机节点读取监控数据是没有意义的。此外，外部访问很容易导致<a href="https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure" target="_blank" rel="noreferrer">敏感数据</a>泄露。</li><li>考虑为每个使用场景定义不同的端点。因此，如果您希望负载均衡器询问您的应用程序监控每个节点的可用性，然后创建一个单独的服务 URL，该 URL 仅提供<code>OK</code>故障或其他任何故障（<code>NOK</code>、404、500、超时）。不要将此与需要更多详细信息的健康检查混为一谈。</li><li>也不要忘记基本功能，例如提供应用程序的名称和发布版本。</li><li>根据监控和健康检查自动做出决策要小心。如果你因为一些监控指标而自动重启你的 pod 或容器，这很容易被证明是愚蠢的。在最坏的情况下，中央组件的故障将导致您的所有应用程序的健康检查报告失败，结果您的所有容器将频繁重启。如果不能解决问题，这样的决定会造成更多的伤害和麻烦。</li><li>避免对您的监控和健康检查本身造成较大的负载。在许多情况下，最好使用日志监控或从应用程序中发生的用例中收集监控数据。如果您在监控实现中创建虚拟读写请求，您很容易将其变成 DOS 攻击。</li></ul><p>对于 spring ，您可以通过<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html" target="_blank" rel="noreferrer">spring-boot-actuator</a>简单地集成应用程序监控和健康检查。</p><p>对于 quarkus ，您可以简单地通过<a href="https://quarkus.io/guides/micrometer" target="_blank" rel="noreferrer">micrometer</a>、<a href="https://quarkus.io/guides/smallrye-metrics" target="_blank" rel="noreferrer">smallrye-metrics</a>集成应用程序监控，以及通过 <a href="https://quarkus.io/guides/smallrye-health" target="_blank" rel="noreferrer">smallrye-health</a>进行健康检查。</p>',9),i=[n];function l(s,c,h,p,g,d){return t(),r("div",null,i)}const f=e(a,[["render",l]]);export{m as __pageData,f as default};
