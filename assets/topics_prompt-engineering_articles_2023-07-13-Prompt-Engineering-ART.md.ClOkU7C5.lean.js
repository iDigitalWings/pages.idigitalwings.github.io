import{_ as t,a as e,af as r,o as i}from"./chunks/framework.C87LdZyP.js";const o="/assets/2820197083435250.TmICyZ14.png",n="/assets/2808520849771583.IkAm8Tv6.png",p="/assets/2808561358851375.BBY_qTHz.png",s="/assets/2813626413181666.By9bnr50.png",l="/assets/2814803672633416.Cf62LQ6l.png",c="/assets/2816258226578791.CU9JZPWp.png",R=JSON.parse('{"title":"PromptEngineering：自动推理并使用工具 (ART)","description":"","frontmatter":{"title":"PromptEngineering：自动推理并使用工具 (ART)","date":"2023-07-12T00:00:00.000Z","tags":["ai","ml"],"category":["AI"]},"headers":[],"relativePath":"topics/prompt-engineering/articles/2023-07-13-Prompt-Engineering-ART.md","filePath":"topics/prompt-engineering/articles/2023-07-13-Prompt-Engineering-ART.md","lastUpdated":1718173059000}'),m={name:"topics/prompt-engineering/articles/2023-07-13-Prompt-Engineering-ART.md"};function g(d,a,h,u,T,A){return i(),e("div",null,a[0]||(a[0]=[r('<div class="admonition abstract"><p class="admonition-title">abstract</p><p>今天介绍一个新的提示框架 ART（<a href="https://arxiv.org/abs/2303.09014" target="_blank" rel="noreferrer">Automatic Reasoning and Tool-use</a>）。 ART 对任务进行拆解，使用精心编写的脚本交替使用模型和工具分步执行，整合工具输出和 LM 输出，最终得到答案。</p></div><p>ART（Automatic Reasoning and Tool-use）的工作原理如下：</p><ul><li>接到一个新任务的时候，从任务库中选择多步推理和使用工具的示范。</li><li>在测试中，调用外部工具时，先暂停生成，将工具输出整合后继续接着生成。</li></ul><p><img src="'+o+'" alt="ART 整体流程"></p><h3 id="任务库" tabindex="-1">任务库 <a class="header-anchor" href="#任务库" aria-label="Permalink to &quot;任务库&quot;">​</a></h3><p>任务库是需要人工准备的，他记录了一个任务应该以什么样的步骤去执行。</p><p>比如我们要一个「把大象装进冰箱」的任务，任务样例库可能有这样一个样例：</p><p><img src="'+n+'" alt="ART任务模板"></p><p>又或者一个「叫外卖」的任务，任务样例库可能有这样一个样例：</p><p><img src="'+p+'" alt="ART 任务模板"></p><p>ART 的第一步就是从任务库中选取合适任务，这一步由 LLM 完成，LLM 根据关键词识别等进行任务的选取。</p><h3 id="工具库" tabindex="-1">工具库 <a class="header-anchor" href="#工具库" aria-label="Permalink to &quot;工具库&quot;">​</a></h3><p>ART 需要一个工具库来执行对应的任务（拆分之后的任务）。</p><p><img src="'+s+'" alt="ART 工具库"></p><p>这一步会把根据任务模板拆解出的问题选择工具执行。</p><p>每当⼦任务查询名称与任务库中的⼯具名称匹配时（例如 「Qi ：[搜索]」），⽣成就会停⽌，并在调⽤该⼯具后恢复 ⽣成，并将其输出合并到部分完成的程序中。</p><h3 id="整合" tabindex="-1">整合 <a class="header-anchor" href="#整合" aria-label="Permalink to &quot;整合&quot;">​</a></h3><p>这一步利用 LLM 的能力整合输出继续后面的问题，当然这个也是顺序执行的，最终得到结果。</p><blockquote><p>整合第一步的输出，调用第二步的工具，整合第二步（也可能加上第一步）的输出，作为第三步的输入，依次进行。</p></blockquote><p><img src="'+l+'" alt="ART 整合输出的过程"></p><h3 id="如何提升" tabindex="-1">如何提升 <a class="header-anchor" href="#如何提升" aria-label="Permalink to &quot;如何提升&quot;">​</a></h3><p>作者还提出了两种可以改进 ART 的方法，一个就是我们之前讲过的 「自洽性」，另一个就是通过人工反馈进行改进。</p><blockquote><p>通过人工反馈可以进行手动扩展，更新任务和工具库去修正推理步骤中的错误或是添加新的工具。</p></blockquote><h2 id="性能" tabindex="-1">性能 <a class="header-anchor" href="#性能" aria-label="Permalink to &quot;性能&quot;">​</a></h2><p>下图展示了作者使用 ART 在 BigBench 和 MMLU 任务上的测试性能。</p><p><img src="'+c+'" alt="ART 在 BigBench 和 MMLU 任务的性能"></p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>ART 通过任务模板和工具，改进了 CoT 并扩展了语言模型的能力（外部工具），直接使用提示的时候我们很少这样使用， 或者下意识在语言模型没法很好的完成预测时，去手动拆解任务执行。但是当我们把这个过程程序化， 就会发挥很好的作用，后续咋开发系列我会给大家一些实际的例子。</p>',28)]))}const b=t(m,[["render",g]]);export{R as __pageData,b as default};
