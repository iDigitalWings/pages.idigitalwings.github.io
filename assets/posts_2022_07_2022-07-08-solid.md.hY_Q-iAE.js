import{_ as l,a as i,o as t,aj as e}from"./chunks/framework.Ba_Ek9Jm.js";const S=JSON.parse('{"title":"SOLID 原则","description":"","frontmatter":{"title":"SOLID 原则","date":"2022-07-08T00:00:00.000Z","tags":["架构"],"category":["架构"]},"headers":[],"relativePath":"posts/2022/07/2022-07-08-solid.md","filePath":"posts/2022/07/2022-07-08-solid.md","lastUpdated":1718173059000}'),s={name:"posts/2022/07/2022-07-08-solid.md"},o=e('<p>在软件工程中，SOLID 是五个设计原则的首字母缩写。 旨在使面向对象的设计更容易理解、 灵活和可维护。</p><p>这些原则是 Robert C.Martin 提倡的许多原则中的一个自己。 在 2000 年的论文《设计原则和设计模式》中首次介绍。</p><p>SOLID是指：</p><ul><li>Single-Responsibility / 单一责任原则 <ul><li>「改变 Class 的理由不应该不止一个。」 换句话说，每个 Class 应该只有一个职责。[6]</li></ul></li><li>Open-Closed / 开放封闭原则 <ul><li>「软件实体......应该对扩展开放，但对修改关闭。」</li></ul></li><li>Liskov Substitution / Liskov 替换原则 <ul><li>「使用指向基类的指针或引用的函数必须能够在不知情的情况下使用派生类的对象。」</li></ul></li><li>Interface segregation / 接口隔离原则 <ul><li>「许多特定于客户端的接口优于一个通用接口。」</li></ul></li><li>Dependency inversion / 依赖倒置原则 <ul><li>「依赖于抽象，而不是具体化。」</li></ul></li></ul><p>SOLID 首字母缩略词是后来在 2004 年左右由 Michael Feathers 引入的。</p><p>关于原则</p><ul><li>原则不是规则，也不是法律。他是很好的建议，但不是一个纯粹的真理。</li><li>原则提供了一个地方来表达我们对好代码和坏代码的感受。它们视图将这些感受归类为具体的建议。</li><li>这些原则是启发式的。它们是常见问题的常识性解决方案。</li><li>它们本质上是经验性的，已观察到他们在很多情况下都有效。并没有任何证据表名他们是有效的。</li><li><strong>遵循绘画规则并不会教会你如何绘画</strong></li></ul><p>如何开始</p><ul><li>不要指望浏览文件就能学到只是 <ul><li>要学习并且研究正确和错误的示例，用心推理</li></ul></li><li>查看自己和他人的代码，查找应用和违反规则的情况，确认这些是否合理。尝试应用一个或者多个原则来改进他们，看看结果是否更好</li><li>和志同道合人人一起讨论</li><li>练习、练习、犯错，继续练习</li><li>将学到的知识使用到工作中，请同事审查</li></ul><hr><ul><li><a href="https://sites.google.com/site/unclebobconsultingllc/getting-a-solid-start" target="_blank" rel="noreferrer">https://sites.google.com/site/unclebobconsultingllc/getting-a-solid-start</a></li></ul>',11),a=[o];function n(r,p,u,c,_,d){return t(),i("div",null,a)}const h=l(s,[["render",n]]);export{S as __pageData,h as default};
