import{_ as i,a,af as e,o as t}from"./chunks/framework.C87LdZyP.js";const p=JSON.parse('{"title":"Id Generator: ID 生成器概述","description":"","frontmatter":{"title":"Id Generator: ID 生成器概述","date":"2022-04-12T00:00:00.000Z","tags":["架构","Java"],"category":["架构"]},"headers":[],"relativePath":"posts/2022/04/2022-04-12-id-generators.md","filePath":"posts/2022/04/2022-04-12-id-generators.md","lastUpdated":1718173059000}'),r={name:"posts/2022/04/2022-04-12-id-generators.md"};function o(d,l,n,u,h,s){return t(),a("div",null,l[0]||(l[0]=[e('<p>全局 ID 使用场景：</p><ul><li>IM 聊天系统的消息 ID</li><li>电商等系统的订单号</li></ul><h2 id="分布式-id-生成器特点" tabindex="-1">分布式 ID 生成器特点 <a class="header-anchor" href="#分布式-id-生成器特点" aria-label="Permalink to &quot;分布式 ID 生成器特点&quot;">​</a></h2><ul><li>全局唯一：</li><li>高性能：高可用低延时，ID 生成响应要快</li><li>高可用：</li><li>易接入：拿来即用，在系统设计和实现上尽可能简单</li><li>趋势递增：尽量趋势递增，提升检索效率</li></ul><h2 id="订单号的需求" tabindex="-1">订单号的需求 <a class="header-anchor" href="#订单号的需求" aria-label="Permalink to &quot;订单号的需求&quot;">​</a></h2><ul><li>安全 <ul><li>不容易被人猜测或者推测（流水号、用户信息等）</li><li>连续流水号容易被扫库或者预测销量</li></ul></li><li>高并发</li><li>长度 <ul><li>10~20位，太短不够用，太长可读性差</li></ul></li><li>尽量使用数字 <ul><li>存储空间小，检索快</li></ul></li></ul><h3 id="淘宝单号" tabindex="-1">淘宝单号 <a class="header-anchor" href="#淘宝单号" aria-label="Permalink to &quot;淘宝单号&quot;">​</a></h3><p>前面为序列号，后四位为卖家ID 的倒数1-2位和买家 ID 倒数的3-4位。</p><h2 id="uuid" tabindex="-1">UUID <a class="header-anchor" href="#uuid" aria-label="Permalink to &quot;UUID&quot;">​</a></h2><p>Java 可以方便的获取 UUID，比如 <code>c2b8c2b9e46c47e3b30dca3b0d447718</code>。</p><ul><li>优点： <ul><li>获取方便，生成简单，本地生成无网络消耗，全球唯一</li></ul></li><li>缺点： <ul><li>字符串长度长（36位），存储行能差，查询耗时</li><li>无序含字母，不具备趋势递增</li><li>无具体业务含义，在业务上使用场景比较少</li></ul></li></ul><h2 id="数据库自增id" tabindex="-1">数据库自增ID <a class="header-anchor" href="#数据库自增id" aria-label="Permalink to &quot;数据库自增ID&quot;">​</a></h2><ul><li>优点 <ul><li>实现简单</li><li>ID 连续单调递增</li><li>数值查询速度快</li></ul></li><li>缺点 <ul><li>MySQL 单点引发瓶颈，存在宕机风险，无法支持高并发</li><li>连续单调递增，使用场景有限制</li></ul></li></ul><h2 id="数据库多主模式" tabindex="-1">数据库多主模式 <a class="header-anchor" href="#数据库多主模式" aria-label="Permalink to &quot;数据库多主模式&quot;">​</a></h2><p>通过不同节点设置<code>起始值</code>和<code>自增步长</code>来解决单点数据库的性能问题。</p><ul><li>优点 <ul><li>解决单点问题</li></ul></li><li>缺点 <ul><li>扩容复杂</li><li>数据瓶颈依然存在</li><li>连续单调自增的问题依然存在</li></ul></li></ul><h2 id="号段模式" tabindex="-1">号段模式 <a class="header-anchor" href="#号段模式" aria-label="Permalink to &quot;号段模式&quot;">​</a></h2><p>号段模式指批量从数据库取号加载到内存，数据库记录取号范围。</p><p>我之前实现的取号算法也是基于号段模式（增加了分布式 Redis 和数据库的双重检查，并实现基于时间的严格递增）。</p><ul><li>优点： <ul><li>主流的 ID 生成方式之一</li><li>趋势自增</li><li>可设计步长等参数</li><li>不用频繁访问数据库</li></ul></li></ul><h2 id="redis" tabindex="-1">Redis <a class="header-anchor" href="#redis" aria-label="Permalink to &quot;Redis&quot;">​</a></h2><p>使用 <code>Redis</code> 的 <code>incr</code> 实现原子递增</p><ul><li>优点 <ul><li>简单</li><li>全局唯一</li></ul></li><li>缺点 <ul><li>需要对 Redis 缓存进行持久化</li><li>有网络开销</li><li>Redis 也有性能瓶颈</li></ul></li></ul><h2 id="snowflake" tabindex="-1">SnowFlake <a class="header-anchor" href="#snowflake" aria-label="Permalink to &quot;SnowFlake&quot;">​</a></h2><p>Twitter 公司公布的分布式 ID 生成算法。 使用 64 bit 长度的 long 整数表示 ID。</p><ul><li>优点 <ul><li>趋势自增</li><li>全局唯一</li><li>一定的可配置性</li></ul></li><li>缺点 <ul><li>实现复杂</li><li>要处理 WorkerId</li><li>time bits 长度决定了可生成的 id 总数</li></ul></li></ul><h2 id="mongodb-objectid" tabindex="-1">MongoDB ObjectId <a class="header-anchor" href="#mongodb-objectid" aria-label="Permalink to &quot;MongoDB ObjectId&quot;">​</a></h2><p>类似 Snowflake，通过 <strong>时间</strong>+<strong>机器码</strong>+<strong>pid</strong>+<strong>inc</strong> 共12个字节（4+3+2+2）的方式， 最终标识成一个24长度的十六进制字符串。</p><h2 id="百度-uidgenerator" tabindex="-1">百度 <a href="https://github.com/baidu/uid-generator" target="_blank" rel="noreferrer">UidGenerator</a> <a class="header-anchor" href="#百度-uidgenerator" aria-label="Permalink to &quot;百度 [UidGenerator](https://github.com/baidu/uid-generator)&quot;">​</a></h2><p>基于 Snowflake 实现的算法。</p><ul><li>使用 Java 实现，作为组件（Jar）引用</li><li>支持自定义 workerId 位数和初始化策略，数据库存储，适用于<strong>容器</strong>等虚拟化的实例运维场景</li><li>通过消费未来时间来克服雪花算法的并发限制</li><li>支持提前生成 ID 并缓存在 RingBuffer 中，以提升性能</li><li>解决时间回拨问题</li></ul><h2 id="美团-leaf" tabindex="-1">美团 <a href="https://github.com/Meituan-Dianping/Leaf" target="_blank" rel="noreferrer">Leaf</a> <a class="header-anchor" href="#美团-leaf" aria-label="Permalink to &quot;美团 [Leaf](https://github.com/Meituan-Dianping/Leaf)&quot;">​</a></h2><p>同时支持 号段模式和 Snowflake 算法。</p><ul><li>单独的服务运行</li><li>雪花算法时需要 zookeeper</li></ul><h2 id="滴滴-tinyid" tabindex="-1">滴滴 <a href="https://github.com/didi/tinyid" target="_blank" rel="noreferrer">TinyID</a> <a class="header-anchor" href="#滴滴-tinyid" aria-label="Permalink to &quot;滴滴 [TinyID](https://github.com/didi/tinyid)&quot;">​</a></h2><p>号段模式的 ID 生成器。支持 http 和 tinyid-client 接入。</p><ul><li>高可用</li><li>低延时</li></ul>',37)]))}const b=i(r,[["render",o]]);export{p as __pageData,b as default};
