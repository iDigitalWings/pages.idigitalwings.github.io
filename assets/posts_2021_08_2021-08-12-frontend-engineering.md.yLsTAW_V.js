import{_ as a,a as e,o as i,aj as l}from"./chunks/framework.Ba_Ek9Jm.js";const b=JSON.parse('{"title":"前端工程化","description":"","frontmatter":{"title":"前端工程化","date":"2021-08-13T00:00:00.000Z","tags":["前端"],"category":["前端"]},"headers":[],"relativePath":"posts/2021/08/2021-08-12-frontend-engineering.md","filePath":"posts/2021/08/2021-08-12-frontend-engineering.md","lastUpdated":1718173059000}'),s={name:"posts/2021/08/2021-08-12-frontend-engineering.md"},t=l(`<h2 id="概念" tabindex="-1">概念 <a class="header-anchor" href="#概念" aria-label="Permalink to &quot;概念&quot;">​</a></h2><p>前端工程化作为现在构架大型 Web 应用不可或缺的一部分。</p><h2 id="为什么需要" tabindex="-1">为什么需要 <a class="header-anchor" href="#为什么需要" aria-label="Permalink to &quot;为什么需要&quot;">​</a></h2><p>前端技术的发展，复杂的业务功能放在了前端，不像之前几个简单的 HTML、CSS、JS 就能完成的。业务复杂伴随着代码复杂， 代码复杂带来代码量大，维护开发工作重。所以前端代码的可靠性、可维护性、可扩展性，以及伴随的性能、开发效率等都 成了前端开发中的重要问题。</p><h2 id="工程化做了什么" tabindex="-1">工程化做了什么 <a class="header-anchor" href="#工程化做了什么" aria-label="Permalink to &quot;工程化做了什么&quot;">​</a></h2><h3 id="提升开发效率" tabindex="-1">提升开发效率 <a class="header-anchor" href="#提升开发效率" aria-label="Permalink to &quot;提升开发效率&quot;">​</a></h3><h4 id="webpack-dev-server-热加载" tabindex="-1">webpack-dev-server 热加载 <a class="header-anchor" href="#webpack-dev-server-热加载" aria-label="Permalink to &quot;webpack-dev-server 热加载&quot;">​</a></h4><p>从之前的刷新页面，甚至需要需要清空缓存的操作，编程一个显示器写代码，另外一个显示器实时看效果。</p><p>webpack-dev-server 有两种模式预加载，一种是 watch 代码修改自动刷新页面，一种是通过 websocket 无刷新把代码替换掉。</p><h4 id="mock-数据" tabindex="-1">Mock 数据 <a class="header-anchor" href="#mock-数据" aria-label="Permalink to &quot;Mock 数据&quot;">​</a></h4><p>前后端分离的架构伴随者前后端分离的开发模式，可以使用 mockjs mock 数据，也可以通过 devServer 模拟真实数据。 减少开发期间的依赖。</p><h4 id="优化性能" tabindex="-1">优化性能 <a class="header-anchor" href="#优化性能" aria-label="Permalink to &quot;优化性能&quot;">​</a></h4><ul><li>代码压缩（为了安全还可能混淆加密）</li><li>较少请求（可以把部门图片base64编码进源文件） <ul><li>Webpack 将小于8k 的图片进行编码 <code>url-loader: loader: &#39;url-loader?limit=8192&#39;</code></li></ul></li><li>静态文件管理。编译后的文件可以使用<code>chunkhash</code>功能生成 hash 后缀，标识版本，减少缓存问题</li></ul><h4 id="提高代码质量" tabindex="-1">提高代码质量 <a class="header-anchor" href="#提高代码质量" aria-label="Permalink to &quot;提高代码质量&quot;">​</a></h4><ul><li><p>模块化</p><p>seajs，requirejs、webpack 等模块化选择大程度提升代码的可维护性。</p></li><li><p>css 预处理</p><p>sass、less、stylus 等预处理器实现样式文件拆分，让 css 具备编程性，提升效率。<code>css-modules</code>避免 css 全局污染问题，不再使用复杂的命名空间和命名规范的管理样式。</p></li><li><p>ES6、babel 编译</p></li><li><p>eslint 代码检查</p></li><li><p>prettier 代码格式化</p></li><li><p>单元测试</p></li><li><p>e2e 测试</p></li><li><p>Web 组件化</p></li></ul><h2 id="工程化历程" tabindex="-1">工程化历程 <a class="header-anchor" href="#工程化历程" aria-label="Permalink to &quot;工程化历程&quot;">​</a></h2><h3 id="script标签的引入" tabindex="-1">script标签的引入 <a class="header-anchor" href="#script标签的引入" aria-label="Permalink to &quot;script标签的引入&quot;">​</a></h3><p>对于有复杂依赖的情况容易发生重复，极难处理。</p><h3 id="模块化标准-amd、cmd、es6" tabindex="-1">模块化标准 AMD、CMD、ES6 <a class="header-anchor" href="#模块化标准-amd、cmd、es6" aria-label="Permalink to &quot;模块化标准 AMD、CMD、ES6&quot;">​</a></h3><p>过度时代的 AMD、CMD 和现行标准 ES6 Module 真正实现了前端的工程化。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">// ES6 </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> React </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &#39;react&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;   </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> { stat, exists, readFile } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &#39;fs&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span></code></pre></div><h3 id="构建打包工具" tabindex="-1">构建打包工具 <a class="header-anchor" href="#构建打包工具" aria-label="Permalink to &quot;构建打包工具&quot;">​</a></h3><p>各种各样的构建工具，gulp、webpack、vite 等，让各种眼花缭乱的前端技术最终能运用在浏览器上。</p><p>css 预处理、代码合并压缩、代码校验、js 转义等一步完成。更有各种 cli 工具，甚至让你可以不了解 任何构建工具都能让你一条命令做好上面的事情。</p><h2 id="美团经验" tabindex="-1">美团经验 <a class="header-anchor" href="#美团经验" aria-label="Permalink to &quot;美团经验&quot;">​</a></h2><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><ul><li>前端开发要自成体系，包括构建、部署、运维，不再和后端项目耦合，后端服务通过 RESTful 端口提供服务</li><li>避免重量级框架，没有一个框架可以满足所有业务场景</li><li>设计要分层，应对需求和技术的变化</li></ul><h3 id="前端工程化项目三大模块" tabindex="-1">前端工程化项目三大模块 <a class="header-anchor" href="#前端工程化项目三大模块" aria-label="Permalink to &quot;前端工程化项目三大模块&quot;">​</a></h3><ul><li>Node 服务，提供数据代理，路由和服务器渲染，通过 RESTful Api 和后端交互</li><li>Web 应用开发，专注 Web 交互体验</li><li>前端运维，包含构建、测试、部署及监控等</li></ul><h4 id="node-服务" tabindex="-1">Node 服务 <a class="header-anchor" href="#node-服务" aria-label="Permalink to &quot;Node 服务&quot;">​</a></h4><p>用语实现前后端分离，核心功能是实现数据代理中转，附带路由分发和服务端渲染功能</p><h4 id="web-应用开发" tabindex="-1">Web 应用开发 <a class="header-anchor" href="#web-应用开发" aria-label="Permalink to &quot;Web 应用开发&quot;">​</a></h4><p>纯前端模块，给予前端工程师极大自由度进行技术选型，专注 Web 交互体验开发</p><h4 id="前端运维" tabindex="-1">前端运维 <a class="header-anchor" href="#前端运维" aria-label="Permalink to &quot;前端运维&quot;">​</a></h4><p>线段项目构建和部署，工程质量（源码质量检查、测试）以及监控（日志、性能）等</p><h4 id="前后端分离" tabindex="-1">前后端分离 <a class="header-anchor" href="#前后端分离" aria-label="Permalink to &quot;前后端分离&quot;">​</a></h4><ul><li>为了彻底的全后端分离，引入 Node 服务层</li><li>Node 端 HTTP 请求得到数据之后，Web 端再从 Node 端获取数据</li></ul>`,37),r=[t];function h(o,n,d,p,c,k){return i(),e("div",null,r)}const m=a(s,[["render",h]]);export{b as __pageData,m as default};
