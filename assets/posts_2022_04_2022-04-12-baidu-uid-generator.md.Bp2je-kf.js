import{_ as d}from"./chunks/ArticleMetadata.DFebsEEb.js";import{_ as s,m as u,a as f,u as c,B as h,e as a,x as l,aj as p,o as t,p as g,q as b}from"./chunks/framework.Ba_Ek9Jm.js";import"./chunks/theme.DmmjVCNk.js";const m="/assets/snowflake.fog_U00d.png",_="/assets/snowflake-baidu.BaM9o0Y7.png",k="/assets/worker-node-data.DY9bFp1J.png",U="/assets/ring-buffer.uRb996cq.png",N=JSON.parse('{"title":"Id Generator: 百度 Uid-Generator","description":"","frontmatter":{"title":"Id Generator: 百度 Uid-Generator","date":"2022-04-12T00:00:00.000Z","tags":["架构","Java"],"category":["架构"]},"headers":[],"relativePath":"posts/2022/04/2022-04-12-baidu-uid-generator.md","filePath":"posts/2022/04/2022-04-12-baidu-uid-generator.md","lastUpdated":1718173059000}'),q={name:"posts/2022/04/2022-04-12-baidu-uid-generator.md"},B=a("h1",{id:"百度-uid-generator",tabindex:"-1"},[l("百度 "),a("a",{href:"https://github.com/baidu/uid-generator",target:"_blank",rel:"noreferrer"},"Uid-Generator"),l(),a("a",{class:"header-anchor",href:"#百度-uid-generator","aria-label":'Permalink to "百度 [Uid-Generator](https://github.com/baidu/uid-generator)"'},"​")],-1),I=p('<p>UidGenerator 由百度开发，基于 Snowflake 算法的唯一 ID 生成器，有如下特点：</p><ul><li>使用 Java 实现，作为组件（Jar）引用</li><li>支持自定义 workerId 位数和初始化策略，数据库存储，适用于<strong>容器</strong>等虚拟化的实例运维场景</li><li>通过消费未来时间来克服雪花算法的并发限制</li><li>支持提前生成 ID 并缓存在 RingBuffer 中，以提升性能</li></ul><h2 id="uid-generator-的-snowflake" tabindex="-1">Uid-Generator 的 Snowflake <a class="header-anchor" href="#uid-generator-的-snowflake" aria-label="Permalink to &quot;Uid-Generator 的 Snowflake&quot;">​</a></h2><h3 id="snowflake-的定义" tabindex="-1">Snowflake 的定义 <a class="header-anchor" href="#snowflake-的定义" aria-label="Permalink to &quot;Snowflake 的定义&quot;">​</a></h3><p><img src="'+m+'" alt=""></p><h3 id="uid-generator-的调整" tabindex="-1">Uid-Generator 的调整 <a class="header-anchor" href="#uid-generator-的调整" aria-label="Permalink to &quot;Uid-Generator 的调整&quot;">​</a></h3><p><img src="'+_+'" alt=""></p><p>算法描述：<strong>指定机器</strong>+<strong>同一时刻</strong>+<strong>并发序列</strong>三个要素生成唯一 ID（64bits Long 值）。</p><p>默认分配方式：</p><ul><li>sign ( bit) <ul><li>固定1bit 符号标识，即生成的 UID 为正整数</li></ul></li><li>delta seconds（28 bits） <ul><li>当前时间和相对时间点 epoch「默认2016-05-20」的增量值，单位「秒」</li><li>28位最多支持约8.7年 <strong>2^(28-1)/86400/365</strong></li><li>如要长期使用，可增加 delta seconds 位数</li><li>epoch 应根据你的上线时间进行配置，不配置的话会浪费几年的可用时间</li></ul></li><li>worker id (22 bits) <ul><li>机器 ID，22位可支持约420w次机器重启。Uid-Generator 内置实现为启动时由数据库分配，默认分配策略 为用后即弃，可实现复用策略</li><li>如果节点频繁重启，可增加 worker id 位数</li></ul></li><li>sequence (13 bits) <ul><li>每秒的并发序列</li><li>13位可支持每秒8192个并发</li><li>如果需要高并发，可增加 sequence 位数</li></ul></li></ul><h2 id="defaultuidgenerator" tabindex="-1">DefaultUidGenerator <a class="header-anchor" href="#defaultuidgenerator" aria-label="Permalink to &quot;DefaultUidGenerator&quot;">​</a></h2><p>实例每次启动的时候，会向 <code>worker_node</code> 表插入一行记录，得到的 id 就是给 workerId 的值。当该值超过 worker id 位数的时候就会抛出异常（默认22位，2^22-1约420w）</p><h3 id="算法概要" tabindex="-1">算法概要 <a class="header-anchor" href="#算法概要" aria-label="Permalink to &quot;算法概要&quot;">​</a></h3><ul><li>检查时钟回拨，如发现时钟回拨则抛出异常</li><li>如果当前时间和上一次是同一秒那么 Sequence 自增</li><li>如果自增超过 Sequence 最大长度，那么自旋等待下一秒（getNextSecond）</li><li>如果是新的一秒，Sequence 从0开始</li></ul><p>每次启动分配 worker id 都会往数据库中插入一条数据。 <img src="'+k+'" alt=""></p><p>配置参数：</p><ul><li>timeBits: delta seconds 的位数</li><li>workerBits</li><li>seqBits</li><li>epochStr: 集成 UidGenerator 生成分布式 ID 服务第一次上线的时间</li></ul><h2 id="cacheduidgenerator" tabindex="-1">CachedUidGenerator <a class="header-anchor" href="#cacheduidgenerator" aria-label="Permalink to &quot;CachedUidGenerator&quot;">​</a></h2><p>CachedUidGenerator 对 DefaultUidGenerator 进行改进，利用 RingBuffer 提升性能。</p><p>RingBuffer 是一个环形数组，数组的每个元素称为一个 slot。RingBuffer 默认为 Snowflake 中 Sequence 的最大值（2^N）。可通过<code>boostPower</code> 参数配置进行扩容，以提高 RingBuffer 读写吞吐量。</p><p>UidGenerator 设计了两个 RingBuffer，一个保存唯一 ID，一个保存 Flag。</p><h3 id="ringbuffer-of-flag" tabindex="-1">RingBuffer of Flag <a class="header-anchor" href="#ringbuffer-of-flag" aria-label="Permalink to &quot;RingBuffer of Flag&quot;">​</a></h3><h3 id="ringbuffer-of-uid" tabindex="-1">RingBuffer of UID <a class="header-anchor" href="#ringbuffer-of-uid" aria-label="Permalink to &quot;RingBuffer of UID&quot;">​</a></h3><p>保存唯一 ID 的 RingBuffer 有两个至真，Tail 指针和 Cursor 指针。</p><p>Tail 指针表示最后一个生成的唯一 ID。如果这个指针追上 Cursor 指针，意味着 RingBuffer 已经满了。 这时候，不允许再生成 ID 了。用户可以通过配置 rejectedPubBufferHandler 指定处理这种情况的策略。</p><p>Cursor 指针表示最后一个已经给消费者的唯一 ID。如果 Cursor 指针追上 Tail 指针。意味着 RingBuffer 已经空了。 只时候，不允许再获取 ID 了。用户可以通过配置 rejectedTakeBufferHandler 指定处理这种异常的策略。</p><p>如果想增强 RingBuffer 的吞吐能力，可以配置 <code>boostPower</code>。</p><p><img src="'+U+'" alt=""></p><h3 id="配置参数" tabindex="-1">配置参数 <a class="header-anchor" href="#配置参数" aria-label="Permalink to &quot;配置参数&quot;">​</a></h3><ul><li>boostPower <ul><li>RingBuffer size扩容参数, 可提高UID生成的吞吐量</li><li>默认:3， 原bufferSize=8192, 扩容后bufferSize= 8192 &lt;&lt; 3 = 65536</li></ul></li><li>paddingFactor <ul><li>指定何时向RingBuffer中填充UID, 取值为百分比(0, 100),</li><li>默认为50</li><li>举例: bufferSize=1024, paddingFactor=50 -&gt; threshold=1024 * 50 / 100 = 512.当环上可用UID数量 &lt; 512时, 将自动对RingBuffer进行填充补全</li></ul></li><li>scheduleInterval <ul><li>另外一种RingBuffer填充时机,</li><li>在Schedule线程中, 周期性检查填充</li><li>默认:不配置此项, 即不使用Schedule线程.</li><li>如需使用, 请指定Schedule线程时间间隔, 单位:秒</li></ul></li></ul><h3 id="优缺点" tabindex="-1">优缺点 <a class="header-anchor" href="#优缺点" aria-label="Permalink to &quot;优缺点&quot;">​</a></h3><ul><li>优点 <ul><li>通过缓存方式预生成 UID，解决 UID 获取耗时</li></ul></li><li>缺点 <ul><li>增加一部分内存缓存 UID</li><li>访问量不大时，提前生成的UID 在后面才会被访问， 时间戳不准确</li></ul></li></ul><div class="tip custom-block"><p class="custom-block-title">借助未来时间</p><p>借助未来时间指并发超出 Sequence 最大值（默认8192）时，delta seconds 只能采用未来的时间来生成 ID。</p></div>',33);function w(e,D,S,G,R,P){const o=d,n=u("ClientOnly");return t(),f("div",null,[B,c(n,null,{default:h(()=>{var r,i;return[(((r=e.$frontmatter)==null?void 0:r.aside)??!0)&&(((i=e.$frontmatter)==null?void 0:i.showArticleMetadata)??!0)?(t(),g(o,{key:0,article:e.$frontmatter},null,8,["article"])):b("",!0)]}),_:1}),I])}const v=s(q,[["render",w]]);export{N as __pageData,v as default};
