import{_ as s,a as t,af as a,o as e}from"./chunks/framework.C87LdZyP.js";const u=JSON.parse('{"title":"Python dynamic modify attribute","description":"","frontmatter":{"title":"Python dynamic modify attribute","date":"2017-10-19T00:00:00.000Z","tags":["python"]},"headers":[],"relativePath":"posts/2017/10/2017-10-19-python-attr.md","filePath":"posts/2017/10/2017-10-19-python-attr.md","lastUpdated":1718193786000}'),n={name:"posts/2017/10/2017-10-19-python-attr.md"};function l(o,i,r,h,d,p){return e(),t("div",null,i[0]||(i[0]=[a(`<h2 id="object" tabindex="-1">object <a class="header-anchor" href="#object" aria-label="Permalink to &quot;object&quot;">​</a></h2><ul><li><p><code>hasattr</code>, <code>getattr</code>, <code>setattr</code></p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">if</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> hasattr</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(obj, </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;name&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">):</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">    setattr</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(obj, </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;name&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;alan&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">)</span></span></code></pre></div></li><li><p><code>dir</code></p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">dir</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(obj)</span></span></code></pre></div></li></ul><p>返回包含obj大多数属性名的列表（会有一些特殊的属性不包含在内）。obj的默认值是当前的模块对象。</p><h2 id="module" tabindex="-1">module <a class="header-anchor" href="#module" aria-label="Permalink to &quot;module&quot;">​</a></h2><ul><li><strong>doc</strong> 文档字符串。如果模块没有文档，这个值是None</li><li><strong>name</strong> 始终是定义时的模块名；即使你使用import .. as 为它取了别名，或是赋值给了另一个变量名。</li><li><strong>dict</strong> 包含了模块里可用的属性名-属性的字典；也就是可以使用模块名.属性名访问的对象。</li><li><strong>file</strong> 包含了该模块的文件路径。需要注意的是内建的模块没有这个属性，访问它会抛出异常！</li></ul><h2 id="class" tabindex="-1">class <a class="header-anchor" href="#class" aria-label="Permalink to &quot;class&quot;">​</a></h2><ul><li><strong>doc</strong> 文档字符串。如果类没有文档，这个值是None。</li><li><strong>name</strong> 始终是定义时的类名。</li><li><strong>dict</strong> 包含了类里可用的属性名-属性的字典；也就是可以使用类名.属性名访问的对象。</li><li><strong>module</strong> 包含该类的定义的模块名；需要注意，是字符串形式的模块名而不是模块对象。</li><li><strong>bases</strong> 直接父类对象的元组；但不包含继承树更上层的其他类，比如父类的父类。</li></ul><h2 id="instance" tabindex="-1">instance <a class="header-anchor" href="#instance" aria-label="Permalink to &quot;instance&quot;">​</a></h2><ul><li><strong>dict</strong> 包含了可用的属性名-属性对象字典。</li><li><strong>class</strong> 该实例的类对象。对于类Cat，cat.<strong>class</strong> == Cat 为 True。</li></ul><h2 id="built-in-functions-and-methods" tabindex="-1">built-in functions and methods <a class="header-anchor" href="#built-in-functions-and-methods" aria-label="Permalink to &quot;built-in functions and methods&quot;">​</a></h2><p>根据定义，内建的(built-in)模块是指使用C写的模块， 可以通过sys模块的builtin_module_names字段查看都有哪些模块是内建的。 这些模块中的函数和方法可以使用的属性比较少，不过一般也不需要在代码中查看它们的信息。</p><ul><li><strong>doc</strong> 函数或方法的文档。</li><li><strong>name</strong> 函数或方法定义时的名字。</li><li><strong>self</strong> 仅方法可用，如果是绑定的(bound)，则指向调用该方法的类（如果是类方法）或实例（如果是实例方法），否则为None。</li><li>*<strong>module</strong> 函数或方法所在的模块名。</li></ul><h2 id="function" tabindex="-1">function <a class="header-anchor" href="#function" aria-label="Permalink to &quot;function&quot;">​</a></h2><p>这里特指非内建的函数。注意，在类中使用def定义的是方法，方法与函数虽然有相似的行为，但它们是不同的概念。</p><ul><li><strong>doc</strong> 函数的文档；另外也可以用属性名func_doc。</li><li><strong>name</strong> 函数定义时的函数名；另外也可以用属性名func_name。</li><li>*<strong>module</strong> 包含该函数定义的模块名；同样注意，是模块名而不是模块对象。</li><li>*<strong>dict</strong> 函数的可用属性；另外也可以用属性名func_dict。 不要忘了函数也是对象，可以使用函数.属性名访问属性（赋值时如果属性不存在将新增一个），或使用内置函数has/get/setattr()访问。不过，在函数中保存属性的意义并不大。</li><li>func_defaults 这个属性保存了函数的参数默认值元组；因为默认值总是靠后的参数才有，所以不使用字典的形式也是可以与参数对应上的。</li><li>func_code 这个属性指向一个该函数对应的code对象，code对象中定义了其他的一些特殊属性，将在下文中另外介绍。</li><li>func_globals 这个属性指向当前的全局命名空间而不是定义函数时的全局命名空间，用处不大，并且是只读的。</li><li>*func_closure 这个属性仅当函数是一个闭包时有效，指向一个保存了所引用到的外部函数的变量cell的元组，这个属性也是只读的。（通过func_closure可以查看必报）</li></ul><h2 id="method" tabindex="-1">method <a class="header-anchor" href="#method" aria-label="Permalink to &quot;method&quot;">​</a></h2><p>方法虽然不是函数，但可以理解为在函数外面加了一层外壳；拿到方法里实际的函数以后，就可以使用2.5节的属性了。</p><ul><li><strong>doc</strong> 与函数相同。</li><li><strong>name</strong> 与函数相同。</li><li>*<strong>module</strong> 与函数相同。</li><li>im_func 使用这个属性可以拿到方法里实际的函数对象的引用。另外如果是2.6以上的版本，还可以使用属性名__func__。</li><li>im_self 如果是绑定的(bound)，则指向调用该方法的类（如果是类方法）或实例（如果是实例方法），否则为None。如果是2.6以上的版本，还可以使用属性名__self__。</li><li>im_class 实际调用该方法的类，或实际调用该方法的实例的类。注意不是方法的定义所在的类，如果有继承关系的话。</li></ul><p>这里讨论的是一般的实例方法，另外还有两种特殊的方法分别是类方法(classmethod)和静态方法(staticmethod)。 类方法还是方法，不过因为需要使用类名调用，所以他始终是绑定的； 而静态方法可以看成是在类的命名空间里的函数（需要使用类名调用的函数）， 它只能使用函数的属性，不能使用方法的属性。</p><h2 id="generator" tabindex="-1">generator <a class="header-anchor" href="#generator" aria-label="Permalink to &quot;generator&quot;">​</a></h2><p>生成器是调用一个生成器函数(generator function)返回的对象，多用于集合对象的迭代。</p><ul><li><strong>iter</strong> 仅仅是一个可迭代的标记。</li><li>gi_code 生成器对应的code对象。</li><li>gi_frame 生成器对应的frame对象。</li><li>gi_running 生成器函数是否在执行。生成器函数在yield以后、执行yield的下一行代码前处于frozen状态，此时这个属性的值为0。</li><li>next|close|send|throw 这是几个可调用的方法，并不包含元数据信息，如何使用可以查看生成器的相关文档。</li></ul><h2 id="inspect-module" tabindex="-1">inspect module <a class="header-anchor" href="#inspect-module" aria-label="Permalink to &quot;inspect module&quot;">​</a></h2><p>inspect模块提供了一系列函数用于帮助使用自省。下面仅列出较常用的一些函数， 想获得全部的函数资料可以查看inspect模块的文档。</p><h3 id="检查对象类型" tabindex="-1">检查对象类型 <a class="header-anchor" href="#检查对象类型" aria-label="Permalink to &quot;检查对象类型&quot;">​</a></h3><ul><li>is{module|class|function|method|builtin}(obj) 检查对象是否为模块、类、函数、方法、内建函数或方法。</li><li>isroutine(obj) 用于检查对象是否为函数、方法、内建函数或方法等等可调用类型。 用这个方法会比多个is*()更方便，不过它的实现仍然是用了多个is*()。</li></ul><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">#coding:utf-8</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> inspect</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> inspect.ismodule(inspect) </span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">#True</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> inspect.isfunction(inspect.isfunction) </span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">#True</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> inspect.isbuiltin(</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">sorted</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">#True</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> inspect.isroutine(</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">sorted</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">#True</span></span></code></pre></div><h3 id="获取对象信息" tabindex="-1">获取对象信息 <a class="header-anchor" href="#获取对象信息" aria-label="Permalink to &quot;获取对象信息&quot;">​</a></h3><ul><li>getmembers(object[, predicate]) 这个方法是dir()的扩展版，它会将dir()找到的名字对应的属性一并返回，形如[(name, value), ...]。另外，predicate是一个方法的引用，如果指定，则应当接受value作为参数并返回一个布尔值，如果为False，相应的属性将不会返回。使用is*作为第二个参数可以过滤出指定类型的属性。</li><li>getmodule(object) 还在为第2节中的__module__属性只返回字符串而遗憾吗？这个方法一定可以满足你，它返回object的定义所在的模块对象。</li><li>get{file|sourcefile}(object) 获取object的定义所在的模块的文件名|源代码文件名（如果没有则返回None）。用于内建的对象（内建模块、类、函数、方法）上时会抛出TypeError异常。</li><li>get{source|sourcelines}(object) 获取object的定义的源代码，以字符串|字符串列表返回。代码无法访问时会抛出IOError异常。只能用于module/class/function/method/code/frame/traceack对象。</li><li>getargspec(func) 仅用于方法，获取方法声明的参数，返回元组，分别是(普通参数名的列表, *参数名, **参数名, 默认值元组)。如果没有值，将是空列表和3个None。如果是2.6以上版本，将返回一个命名元组(Named Tuple)，即除了索引外还可以使用属性名访问元组中的元素。</li></ul><hr><p>Links:</p><ul><li><a href="http://www.cnblogs.com/zh1164/p/6031464.html" target="_blank" rel="noreferrer">python动态获取对象的属性和方法 （转载）</a></li></ul><hr><div style="text-align:center;color:#00000099;font-size:14px;">END</div>`,34)]))}const g=s(n,[["render",l]]);export{u as __pageData,g as default};
