import{_ as a,a as i,o as s,aj as e}from"./chunks/framework.Ba_Ek9Jm.js";const t="/assets/cola-1.0.DPeRlGqT.png",l="/assets/cola-2.0.BaoqUpDb.png",n="/assets/cola2-components.Ca44FxOd.png",o="/assets/cola2-comp-app.BOdaQPMM.png",r="/assets/extension-biz.B7ScLEax.png",p="/assets/extension1.Rcqa8gpj.png",h="/assets/extension2.CSLaHNTu.png",d="/assets/shared-kernel.Df4zgLN4.png",c="/assets/acl.BHoiF6S8.png",k="/assets/cola-arch-dep.K9jW_w1K.png",u="/assets/cola-arch-call.F95HiAJn.png",f=JSON.parse('{"title":"Cola 2.0 笔记","description":"","frontmatter":{"title":"Cola 2.0 笔记","date":"2021-07-27T00:00:00.000Z","tags":["ddd","cola"],"category":["设计"]},"headers":[],"relativePath":"posts/2021/07/2021-07-27-cola-2.0.md","filePath":"posts/2021/07/2021-07-27-cola-2.0.md","lastUpdated":1718173059000}'),g={name:"posts/2021/07/2021-07-27-cola-2.0.md"},m=e('<h2 id="系统问题" tabindex="-1">系统问题 <a class="header-anchor" href="#系统问题" aria-label="Permalink to &quot;系统问题&quot;">​</a></h2><p>觉得系统混乱，系统混乱的表现：</p><ul><li>应用层次结构混乱：不知道应用如何分层、每一层包含什么组件、每个组件包含什么功能、组件之间关系是什么</li><li>缺少规范的知道和约束：新的业务逻辑不知道放在什么包、什么类，起什么名字</li></ul><h2 id="cola-架构" tabindex="-1">Cola 架构 <a class="header-anchor" href="#cola-架构" aria-label="Permalink to &quot;Cola 架构&quot;">​</a></h2><p>Cola的初心之一：</p><blockquote><p>试图探索一套切实可行的应用架构规范，这个规范不是高高在上的纸上谈兵，而是可以复制、可以理解、可以落地、可以控制复杂性的指导和约束</p></blockquote><p>Cola 1.0的经典分层架构：</p><p><img src="'+t+'" alt="img.png"></p><p>Cola 2.0的架构设计。Domain 和 Infrastructure 的依赖发生变化，通过 Gateway 的引入， 使用 DIP（Dependency Inversion Principle 依赖倒置） 反转依赖关系，使 Domain 层更加纯粹， 包拖了 Domain 对技术细节(Infrastructure)的依赖，只需要关系业务逻辑的处理。</p><p><img src="'+l+'" alt="img.png"></p><p>这样的解耦同样带来了别的好处：</p><ul><li>接口约定好，Domain 和 Infrastructure 可以并行开发</li><li>可以更好的进行单元测试</li></ul><h2 id="组件划分" tabindex="-1">组件划分 <a class="header-anchor" href="#组件划分" aria-label="Permalink to &quot;组件划分&quot;">​</a></h2><h3 id="模块和组件" tabindex="-1">模块和组件 <a class="header-anchor" href="#模块和组件" aria-label="Permalink to &quot;模块和组件&quot;">​</a></h3><p>通常认为模块和组件的概念相近，Module 的 Scope 更大。在 Java 中可以定义为：</p><ul><li>Module：Jar</li><li>Component： Package</li></ul><h3 id="cola-2-0-组件" tabindex="-1">Cola 2.0 组件 <a class="header-anchor" href="#cola-2-0-组件" aria-label="Permalink to &quot;Cola 2.0 组件&quot;">​</a></h3><p>组件如下： <img src="'+n+'" alt="img.png"></p><p>对应的应用结构如下; <img src="'+o+'" alt="img.png"></p><p>组件定义了自己的职责，对开发形成知道和约束：</p><ol><li>二方库的组件 <ul><li>api - 存放应用对外的接口</li><li>dto.domain_model - 做数据传输的轻量级领域对象</li><li>dto.domain_event - 做数据传输的领域对象</li></ul></li><li>Application 的组件 <ul><li>service - 接口实现的 facade，不包含业务逻辑实现，使用不同终端的 adapter</li><li>event_handler - 处理领域事件，包含本域的和外域的</li><li>executor - 用来处理 Command 和 Query，对复杂业务，可以包含 Phase 和 Step</li><li>interceptor - Cola 提供的对所有请求的 AOP 机制</li></ul></li><li>Domain 的组件 <ul><li>domain - 领域实体，允许集成 domain_model</li><li>domain_service - 领域服务，提供更粗粒度的领域能力</li><li>gateway - 对外依赖的网关接口，比如存储、RPC、Search 等</li></ul></li><li>Infrastructure 的组件 <ul><li>config - 配置相关信息</li><li>message - 消息处理相关</li><li>repository - 存储相关</li><li>gateway - 对外依赖的网关接口 Domain.gateway 的实现</li></ul></li></ol><h2 id="扩展点" tabindex="-1">扩展点 <a class="header-anchor" href="#扩展点" aria-label="Permalink to &quot;扩展点&quot;">​</a></h2><h3 id="相关概念" tabindex="-1">相关概念 <a class="header-anchor" href="#相关概念" aria-label="Permalink to &quot;相关概念&quot;">​</a></h3><ul><li>业务 Business - 自负盈亏的财务主体，比如 天猫、淘宝、零售通</li><li>用例 User Case - 用户和系统之间的互动。每个用户提供一个或多个场景。比如订单支付</li><li>场景 Scenario - 用例的示例的归纳。包含所有正常和非正常的情况。对于订单支付这个场景，比如：使用花呗支付、支付宝余额不足等</li></ul><p>比如： <img src="'+r+`" alt="img.png"></p><h3 id="扩展实现" tabindex="-1">扩展实现 <a class="header-anchor" href="#扩展实现" aria-label="Permalink to &quot;扩展实现&quot;">​</a></h3><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Extension</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">bizId</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &quot;tmall&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">useCase</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &quot;placeOrder&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">scenario</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &quot;88vip&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> IdentityCheck88VipExt</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> IdentityCheckExtPt</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><h3 id="扩展机制" tabindex="-1">扩展机制 <a class="header-anchor" href="#扩展机制" aria-label="Permalink to &quot;扩展机制&quot;">​</a></h3><h4 id="基于接口" tabindex="-1">基于接口 <a class="header-anchor" href="#基于接口" aria-label="Permalink to &quot;基于接口&quot;">​</a></h4><p><img src="`+p+'" alt="img.png"></p><p>比如 <code>ExceptionHandlerI</code>，框架提供了一个默认实现 <code>DefaultExceptionHandler</code>。</p><p>如果用户实现了 <code>ExceptionHandlerI</code> 则优先使用用户实现的。</p><h4 id="基于数据配置" tabindex="-1">基于数据配置 <a class="header-anchor" href="#基于数据配置" aria-label="Permalink to &quot;基于数据配置&quot;">​</a></h4><p><img src="'+h+'" alt="img.png"></p><p>比如扩展点的配置：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Extension</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">bizId</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &quot;tmall&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">useCase</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &quot;placeOrder&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">scenario</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &quot;88vip&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">)</span></span></code></pre></div><h2 id="二方库" tabindex="-1">二方库 <a class="header-anchor" href="#二方库" aria-label="Permalink to &quot;二方库&quot;">​</a></h2><p>服务的二方库：<strong>用来暴露接口和传递数据（DTO），涉及不同界限上下文（Bounded Context）之间的协作问题</strong></p><h3 id="bounded-context-之间的协作" tabindex="-1">Bounded Context 之间的协作 <a class="header-anchor" href="#bounded-context-之间的协作" aria-label="Permalink to &quot;Bounded Context 之间的协作&quot;">​</a></h3><h4 id="_1-共享内核-shared-kernel" tabindex="-1">1. 共享内核 Shared Kernel <a class="header-anchor" href="#_1-共享内核-shared-kernel" aria-label="Permalink to &quot;1. 共享内核 Shared Kernel&quot;">​</a></h4><p><img src="'+d+'" alt="img.png"></p><ul><li>优点：减少重复</li><li>缺点：团队间耦合</li></ul><blockquote><p>An Anticorruption Layer is the most defensive Context Mapping relationship, where the downstream team creates a translation layer between its Ubiquitous Language (model) and the Ubiquitous Language (model) that is upstream to it.</p></blockquote><h4 id="_2-防腐层-acl-anti-corruption-layer" tabindex="-1">2. 防腐层 ACL，Anti-Corruption Layer <a class="header-anchor" href="#_2-防腐层-acl-anti-corruption-layer" aria-label="Permalink to &quot;2. 防腐层 ACL，Anti-Corruption Layer&quot;">​</a></h4><p><img src="'+c+'" alt="img.png"></p><ul><li>优点：最彻底的隔离。没有 Share，完全结构</li><li>缺点：没有 Share，有转换成本</li></ul><blockquote><p>Whenever possible, you should try to create an Anticorruption Layer between your downstream model and an upstream integration model, so that you can produce model concepts on your side of the integration that specifically fit your business needs and that keep you completely isolated from foreign concepts.</p></blockquote><h3 id="二方库定位" tabindex="-1">二方库定位 <a class="header-anchor" href="#二方库定位" aria-label="Permalink to &quot;二方库定位&quot;">​</a></h3><p>二方库用来定义服务接口和数据协议，区别于 Json 不仅仅是协议，还是一个 Java 对象，一个 Jar 包， 可以承载 getter，setter 之外的更多职责。</p><p>可以有自己的方法，可以继承，组合。</p><h2 id="cola-2-0-整体架构" tabindex="-1">Cola 2.0 整体架构 <a class="header-anchor" href="#cola-2-0-整体架构" aria-label="Permalink to &quot;Cola 2.0 整体架构&quot;">​</a></h2><p>依赖视图： <img src="'+k+'" alt="img.png"></p><p>调用视图： <img src="'+u+'" alt="img.png"></p>',53),C=[m];function y(b,_,q,A,F,D){return s(),i("div",null,C)}const B=a(g,[["render",y]]);export{f as __pageData,B as default};
