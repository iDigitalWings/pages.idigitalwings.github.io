import{_ as i,a,o as s,aj as e}from"./chunks/framework.Ba_Ek9Jm.js";const m=JSON.parse('{"title":"Guava RateLimiter","description":"","frontmatter":{"title":"Guava RateLimiter","date":"2017-11-09T00:00:00.000Z","tags":["guava","ratelimeiter","design"],"category":["Java"]},"headers":[],"relativePath":"posts/2017/11/2017-11-09-guava-ratelimiter.md","filePath":"posts/2017/11/2017-11-09-guava-ratelimiter.md","lastUpdated":1718173059000}'),t={name:"posts/2017/11/2017-11-09-guava-ratelimiter.md"},r=e(`<p>从 <a href="https://code.google.com/p/guava-libraries/" target="_blank" rel="noreferrer">Guava Libraries</a> <code>13.0</code> 智斗增加了 <a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/util/concurrent/RateLimiter.html" target="_blank" rel="noreferrer">RateLimiter</a> 类。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span>[...] rate limiter distributes permits at a configurable rate. Each acquire() blocks if necessary until a permit is available [...] Rate limiters are often used to restrict the rate at which some physical or logical resource is accessed</span></span></code></pre></div><div class="language-groovy vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">groovy</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">final</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> RateLimiter</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;"> rateLimiter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> RateLimiter.</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">create(</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">2.0</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> submitTasks</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    rateLimiter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">acquire(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">// 也许需要等待</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> rateLimiter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">tryAcquire(</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">TimeUnit.</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">MILLISECONDS</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><h2 id="令牌桶算法" tabindex="-1">令牌桶算法 <a class="header-anchor" href="#令牌桶算法" aria-label="Permalink to &quot;令牌桶算法&quot;">​</a></h2><ol><li>每秒会有 r 个令牌放入桶中，或者说，每过 1/r 秒桶中增加一个令牌</li><li>桶中最多存放 b 个令牌，如果桶满了，新放入的令牌会被丢弃</li><li>当一个 n 字节的数据包到达时，消耗 n 个令牌，然后发送该数据包</li><li>如果桶中可用令牌小于 n，则该数据包将被缓存或丢弃</li></ol><p>令牌桶控制的是一个时间窗口内的通过的数据量，在 API 层面我们常说的 QPS、TPS， 正好是一个时间窗口内的请求量或者事务量，只不过时间窗口限定在 1s 罢了。</p><p>现实世界的网络工程中使用的令牌桶，比概念图中的自然是复杂了许多， 「令牌桶」的数量也不是一个而是两个，简单的算法描述可用参考中兴的期刊^1或者 RFC。</p><p>假如项目使用 Java 语言，我们可以轻松地借助 Guava 的 RateLimiter 来实现基于令牌桶的流控。RateLimiter 令牌桶算法的单桶实现， 也许是因为在 Web 应用层面单桶实现就够用了，双筒实现就属于过度设计。</p><p>RateLimiter 对简单的令牌桶算法做了一些工程上的优化，具体的实现是 SmoothBursty。 需要注意的是，RateLimiter 的另一个实现 SmoothWarmingUp，就不是令牌桶了， 而是漏桶算法。也许是出于简单起见，RateLimiter 中的时间窗口能且仅能为 1s， 如果想搞其他时间单位的限流，只能另外造轮子。</p><p>SmoothBursty 积极响应李克强总理的号召，上个月的流量没用完，可以挪到下个月用。 其实就是 SmoothBursty 有一个可以放 N 个时间窗口产生的令牌的桶， 系统空闲的时候令牌就一直攒着，最好情况下可以扛 N 倍于限流值的高峰而不影响后续请求。 如果不想像三峡大坝一样能扛千年一遇的洪水，可以把 N 设置为 1， 这样就只屯一个时间窗口的令牌。</p><p>RateLimiter 有一个有趣的特性是「前人挖坑后人跳」， 也就是说 RateLimiter 允许某次请求拿走超出剩余令牌数的令牌， 但是下一次请求将为此付出代价，一直等到令牌亏空补上， 并且桶中有足够本次请求使用的令牌为止[^2]。这里面就涉及到一个权衡， 是让前一次请求干等到令牌够用才走掉呢，还是让它先走掉后面的请求等一等呢？ Guava 的设计者选择的是后者，先把眼前的活干了，后面的事后面再说。</p><hr><ul><li><a href="https://dzone.com/articles/ratelimiter-discovering-google" target="_blank" rel="noreferrer">RateLimiter - Discovering Google Guava</a></li><li><a href="http://blog.csdn.net/lzw_2006/article/details/51789859" target="_blank" rel="noreferrer">系统限流实践 - 应用限流</a></li><li><a href="http://blog.csdn.net/lzw_2006/article/details/51880563" target="_blank" rel="noreferrer">系统限流实践 - 分布式限流</a></li><li><a href="http://blog.csdn.net/lzw_2006/article/details/51909516" target="_blank" rel="noreferrer">系统限流实践 - 接入层限流(下*完结)</a></li></ul>`,13),l=[r];function n(h,p,o,k,d,c){return s(),a("div",null,l)}const u=i(t,[["render",n]]);export{m as __pageData,u as default};
