import{_ as e,a as t,o as i,aj as l}from"./chunks/framework.Ba_Ek9Jm.js";const a="/assets/b-tree.Cgk98yCb.jpg",M=JSON.parse('{"title":"B-Tree","description":"","frontmatter":{"title":"B-Tree","date":"2017-07-27T00:00:00.000Z","tags":["tree","algorithm"],"category":["算法"]},"headers":[],"relativePath":"posts/2017/07/2017-07-27-b-tree.md","filePath":"posts/2017/07/2017-07-27-b-tree.md","lastUpdated":1718193786000}'),o={name:"posts/2017/07/2017-07-27-b-tree.md"},r=l('<blockquote><p>B树,不是B减树.</p></blockquote><h2 id="定义" tabindex="-1">定义 <a class="header-anchor" href="#定义" aria-label="Permalink to &quot;定义&quot;">​</a></h2><p>是一种多路搜索树（并不是二叉的）：</p><ol><li>定义任意非叶子结点最多只有 M 个儿 子；且 M&gt;2 ；</li><li>根结点的儿子数为 [2, M] ；</li><li>除根结点以外的非叶子结点的儿子数为 [M/2, M] ；</li><li>每个结点存放至少 M/2-1 （取 上整）和至多 M-1 个关键字；（至少 2 个关键 字）</li><li>非叶子结点的关键字个数 = 指向儿 子的指针个数 -1 ；</li><li>非叶子结点的关键字： K[1], K[2], …, K[M-1] ；且 K[i] &lt; K[i+1] ；</li><li>非叶子结点的指针： P[1], P[2], …, P[M] ；其中 P[1] 指向关键字小于 K[1] 的子树， P[M] 指向关键字大于 K[M-1] 的子树，其它 P[i] 指 向关键字属于 (K[i-1], K[i]) 的子树；</li><li>所有叶子结点位于同一层；</li></ol><p>如：（ M=3 ）</p><p><img src="'+a+'" alt=""></p><p>B-树的特性：</p><ol><li>关键字集合分布在整颗树中；</li><li>任何一个关键字出现且只出现在一个结点中；</li><li>搜索有可能在非叶子结点结束；</li><li>其搜索性能等价于在关键字全集内做一次二分查找；</li><li>自动层次控制；</li></ol><p>由于限制了除根结点以外的非叶子结点，至少含有 M/2 个儿子，确保了结点的至少利用率</p><hr><p>Links:</p><ul><li><a href="http://www.oschina.net/question/565065_86338" target="_blank" rel="noreferrer">http://www.oschina.net/question/565065_86338</a></li></ul><hr><div style="text-align:center;color:#00000099;font-size:14px;">END</div>',14),s=[r];function n(p,_,c,d,h,m){return i(),t("div",null,s)}const f=e(o,[["render",n]]);export{M as __pageData,f as default};
