import{_ as e,a as i,o as l,aj as t}from"./chunks/framework.Ba_Ek9Jm.js";const b=JSON.parse('{"title":"MySql binlog format","description":"","frontmatter":{"title":"MySql binlog format","date":"2017-07-27T00:00:00.000Z","tags":["mysql","binlog"]},"headers":[],"relativePath":"posts/2017/07/2017-07-27-mysql-binlog-format.md","filePath":"posts/2017/07/2017-07-27-mysql-binlog-format.md","lastUpdated":1718193786000}'),o={name:"posts/2017/07/2017-07-27-mysql-binlog-format.md"},a=t('<p>MySql二进制日志(binlog)有<code>3</code>种不同的格式可选：<code>Mixed</code>,<code>Statement</code>,<code>Row</code>， 默认格式是<code>Statement</code>.</p><h2 id="row" tabindex="-1">Row <a class="header-anchor" href="#row" aria-label="Permalink to &quot;Row&quot;">​</a></h2><p>日志中会记录成每一行数据被修改的形式.</p><p>不记录执行的SQL语句的上下文相关的信息， 仅仅只需要记录哪一条记录被修改了，修改成什么样了.</p><p>比如:</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">update</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> table</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> user </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">set</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> password=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;xxx&#39;</span></span></code></pre></div><p>那么影响的每一条记录都会被日志记下来.</p><h2 id="statement" tabindex="-1">Statement <a class="header-anchor" href="#statement" aria-label="Permalink to &quot;Statement&quot;">​</a></h2><p>每一条会修改数据的SQL都会记录到bin-log中.</p><p><code>Statement</code>模式没有<code>Row</code>模式日志文件大的问题,但是部分函数不能正确复制,比如<code>sleep</code>.</p><h2 id="mixed" tabindex="-1">Mixed <a class="header-anchor" href="#mixed" aria-label="Permalink to &quot;Mixed&quot;">​</a></h2><p><code>5.1.8</code>版本之后提供了<code>Mixed</code>模式,即两种模式的结合.</p><p>比如<code>alter</code>操作使用<code>statement</code>模式,<code>update</code>,<code>delete</code>使用<code>statemest</code>模式.</p><p>如果binlog采用了<code>Mixed</code>模式,那么在以下几种情况下会自动将binlog的模式由<code>Statement</code>模式变为<code>Row</code>模式：</p><ol><li>当<code>DML</code>语句更新一个<code>NDB</code>表时 (<code>NDB</code> MySql Cluster 的存储引擎)</li><li>当函数中包含<code>UUID()</code>时</li><li>2个及以上包含<code>AUTO_INCREMENT</code>字段的表被更新时</li><li>执行<code>INSERT DELAYED</code>语句时</li><li>用<code>UDF</code>时</li><li>视图中必须要求运用<code>Row</code>时,例如建立视图时使用了<code>UUID()</code>函数</li></ol><hr><p>ps:</p><ul><li><code>DDL</code> 数据库模式定义语言 <code>create</code></li><li><code>DML</code> 数据操纵语言 <code>Insert/delete/update</code></li><li><code>DCL</code> 数据库控制语言 <code>grant/remove</code></li><li><code>DQL</code> 数据库查询语言 <code>select</code></li></ul><hr><h2 id="两种模式的对比" tabindex="-1">两种模式的对比 <a class="header-anchor" href="#两种模式的对比" aria-label="Permalink to &quot;两种模式的对比&quot;">​</a></h2><h3 id="statement-优点" tabindex="-1">Statement 优点 <a class="header-anchor" href="#statement-优点" aria-label="Permalink to &quot;Statement 优点&quot;">​</a></h3><ul><li>历史悠久，技术成熟；</li><li>产生的 binlog 文件较小；</li><li>binlog 中包含了所有数据库修改信息，可以据此来审核数据库的安全等情况；</li><li>binlog 可以用于实时的还原，而不仅仅用于复制；</li><li>主从版本可以不一样，从服务器版本可以比主服务器版本高；</li></ul><h3 id="statement-缺点" tabindex="-1">Statement 缺点： <a class="header-anchor" href="#statement-缺点" aria-label="Permalink to &quot;Statement 缺点：&quot;">​</a></h3><ul><li>不是所有的 UPDATE 语句都能被复制，尤其是包含不确定操作的时候；</li><li>调用具有不确定因素的 UDF 时复制也可能出现问题；</li><li>运用以下函数的语句也不能被复制：</li><li>LOAD_FILE()</li><li>UUID()</li><li>USER()</li><li>FOUND_ROWS()</li><li>SYSDATE() (除非启动时启用了 –sysdate-is-now 选项)</li><li>INSERT … SELECT 会产生比 RBR 更多的行级锁；</li><li>复制须要执行全表扫描 (WHERE 语句中没有运用到索引) 的 UPDATE 时，须要比 row 请求更多的行级锁；</li><li>对于有 AUTO_INCREMENT 字段的 InnoDB 表而言，INSERT 语句会阻塞其他 INSERT 语句；</li><li>对于一些复杂的语句，在从服务器上的耗资源情况会更严重，而 row 模式下，只会对那个发生变化的记录产生影响；</li><li>存储函数(不是存储流程 )在被调用的同时也会执行一次 NOW() 函数，这个可以说是坏事也可能是好事；</li><li>确定了的 UDF 也须要在从服务器上执行；</li><li>数据表必须几乎和主服务器保持一致才行，否则可能会导致复制出错；</li><li>执行复杂语句如果出错的话，会消耗更多资源；</li></ul><h3 id="row-优点" tabindex="-1">Row 优点 <a class="header-anchor" href="#row-优点" aria-label="Permalink to &quot;Row 优点&quot;">​</a></h3><ul><li>任何情况都可以被复制，这对复制来说是最安全可靠的；</li><li>和其他大多数数据库系统的复制技能一样；</li><li>多数情况下，从服务器上的表如果有主键的话，复制就会快了很多；</li><li>复制以下几种语句时的行锁更少：</li><li>INSERT … SELECT</li><li>包含 AUTO_INCREMENT 字段的 INSERT</li><li>没有附带条件或者并没有修改很多记录的 UPDATE 或 DELETE 语句</li><li>执行 INSERT，UPDATE，DELETE 语句时锁更少；</li><li>从服务器上采用多线程来执行复制成为可能；</li></ul><h3 id="row-缺点" tabindex="-1">Row 缺点 <a class="header-anchor" href="#row-缺点" aria-label="Permalink to &quot;Row 缺点&quot;">​</a></h3><ul><li>生成的 binlog 日志体积大了很多；</li><li>复杂的回滚时 binlog 中会包含大量的数据；</li><li>主服务器上执行 UPDATE 语句时，所有发生变化的记录都会写到 binlog 中，而 statement 只会写一次，这会导致频繁发生 binlog - 的写并发请求；</li><li>UDF 产生的大 BLOB 值会导致复制变慢；</li><li>不能从 binlog 中看到都复制了写什么语句(加密过的)；</li><li>当在非事务表上执行一段堆积的 SQL 语句时，最好采用 statement 模式，否则很容易导致主从服务器的数据不一致情况发生；</li><li>另外，针对系统库 MySQL 里面的表发生变化时的处理准则如下：</li><li>如果是采用 INSERT，UPDATE，DELETE 直接操作表的情况，则日志格式根据 binlog_format 的设定而记录；</li><li>如果是采用 GRANT，REVOKE，SET PASSWORD 等管理语句来做的话，那么无论如何都要使用 statement 模式记录；</li><li>使用 statement 模式后，能处理很多原先出现的主键重复问题；</li></ul><hr><div style="text-align:center;color:#00000099;font-size:14px;">END</div>',30),d=[a];function s(c,n,r,h,p,m){return l(),i("div",null,d)}const u=e(o,[["render",s]]);export{b as __pageData,u as default};
